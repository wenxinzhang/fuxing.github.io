{"meta":{"title":"福星","subtitle":null,"description":null,"author":"福 星","url":"http://zhangfuxin.cn"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-08-28T12:45:14.375Z","updated":"2019-08-21T14:54:19.909Z","comments":true,"path":"hello-world.html","link":"","permalink":"http://zhangfuxin.cn/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"如何选购合适的电脑","slug":"buy-computer","date":"2019-08-28T09:34:04.000Z","updated":"2019-08-28T16:18:54.332Z","comments":true,"path":"buy-computer.html","link":"","permalink":"http://zhangfuxin.cn/buy-computer.html","excerpt":"** 购买合适的电脑：** &lt;Excerpt in index | 首页摘要&gt;随着时代的发展，人们生活水平的提高，计算机也成为了我们工作必不可少的生产力，办公，打游戏，看电影，购物等等。市面上电脑种类根据用途又可以分为很多类，台式机、笔记本、ipad（平板）。购买一个合适自己的电脑显得尤为重要，电脑不舒服，用着影响心情。","text":"** 购买合适的电脑：** &lt;Excerpt in index | 首页摘要&gt;随着时代的发展，人们生活水平的提高，计算机也成为了我们工作必不可少的生产力，办公，打游戏，看电影，购物等等。市面上电脑种类根据用途又可以分为很多类，台式机、笔记本、ipad（平板）。购买一个合适自己的电脑显得尤为重要，电脑不舒服，用着影响心情。 &lt;The rest of contents | 余下全文&gt; 买电脑主要需求 看电影，上网（购物） 打游戏 办公（移动办公） 平面设计（3维制图） UI(影视剪辑) 编程 电脑配置说明目前电脑配置的CPU（绝对过剩），内存Win10最低要8个G，显卡要根据自己需求一般显卡基本够用，电脑最大的瓶颈都是在硬盘上，所以现在买电脑带不带固态硬盘是我首选的配置（我对固态硬盘定义最低要128G,512G固态才是标配，毕竟固态大小会影响到一定的读写速率，还有为了保证固态寿命做系统时会留出10%的空间不划分到分区中），至于买笔记本还是台式机需要根据不同应用场景来定。台式机性能肯定远超同价位笔记本，这个是毋庸置疑的。 看电影，上网（购物）对于这方面需求的一般一女生居多，看电影上网，对电脑配置要求比较低的，一般普通双核CPU，AMD、酷睿i3都可以（最好是i5），内存8G就够了（win7的话4G就够，但是Win7现在不支持更新了）。要是女生最重要的是漂亮，这里推荐DELL或者HP相对性价比会比较合适。毕竟要是要以轻薄、美观为主。要是资金充足可以考虑各家品牌的超极本。要是父母的需求的话其实买笔记本或者台式机都可以。这里不推荐苹果笔记本，应为用苹果看电影会容易热，要是妹子是苹果控或者周边产品都是苹果产品，苹果笔记本也可在考虑之列。 打游戏游戏主机两个最主要的要求配置和扩展性，主要是CPU和显卡，我们又称之为“双烧”，建议买台式机。要是需要便携的话，外星人品牌是一个不错的考虑，笔记本显卡最好不要超过2070以上，也许你会问为什么不买笔记本2080的本子，一方面试贵，价格会差很多。还有就是散热问题。为了更好体验还是台式机加水冷。 一般的主流网游：i5或i7处理器，内存16G，中端显卡就可以了，硬盘128G固态+1T机械起 大型单机：i7或i9处理器（水冷），内存16-32G，，显卡中高端GTX1060起，要是玩刺客信条奥德赛GTX2080Ti不用犹豫，硬盘512三星固态+1T机械（最好在配置1T的固态，毕竟游戏不小）起 发烧友：i9处理器（水冷），内存32G-64G，显卡高端GTX2080或者是多显交火，硬盘512G（三星固态PRO系列）+1T固态 办公用于办公的大多是商务人士，对笔记本的性能要求一般，最主要的是便携性，各大品牌的超极本都很合适，还能衬托气质，最推荐的还是联想的thinkpad系列，没钱买个E系类（基本三年就会坏），要是有资金充裕T系列或者X系列是首选配置（尤其是X系列）。 平面设计（3维制图）这个是专业领域的需求，对CPU、显卡和内存、显示器都较高，能好一点就好一点。 UI(影视剪辑)苹果的Macbookpro 16G，512SSD（固态太小用久了会后悔的），i7处理器 最为合适。没有比苹果更适合做平面设计的电脑。Windows系统和苹果系统没得比。 编程苹果的Macbookpro 16G、512SSD、i7处理器。个人推荐MAC的笔记本做编程，一用就停不下来，会上瘾。Windows系统用来打游戏就好了。推荐配置：Macbookpro 16G、i7处理器（i9也是阉割版没意义）、512SSD（固态真的不能太小，512G就不大，考虑到价格没办法）、最好是能带键盘灯。","categories":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/categories/others/"}],"tags":[{"name":"数码产品","slug":"数码产品","permalink":"http://zhangfuxin.cn/tags/数码产品/"}],"keywords":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/categories/others/"}]},{"title":"分布式锁的几种实现方式","slug":"dslock","date":"2018-03-02T14:18:29.000Z","updated":"2019-08-21T15:13:24.123Z","comments":true,"path":"dslock.html","link":"","permalink":"http://zhangfuxin.cn/dslock.html","excerpt":"** 分布式锁的几种实现方式：** &lt;Excerpt in index | 首页摘要&gt;在分布式架构中，由于多线程和多台服务器，何难保证顺序性。如果需要对某一个资源进行限制，比如票务，比如请求幂等性控制等，这个时候分布式锁就排上用处。","text":"** 分布式锁的几种实现方式：** &lt;Excerpt in index | 首页摘要&gt;在分布式架构中，由于多线程和多台服务器，何难保证顺序性。如果需要对某一个资源进行限制，比如票务，比如请求幂等性控制等，这个时候分布式锁就排上用处。 &lt;The rest of contents | 余下全文&gt; 什么是分布式锁分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。 分布式锁需要解决的问题 互斥性：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁。 安全性：锁只能被持有该锁的客户端删除，不能由其它客户端删除。 死锁：获取锁的客户端因为某些原因（如down机等）而未能释放锁，其它客户端再也无法获取到该锁。 容错：当部分节点（redis节点等）down机时，客户端仍然能够获取锁和释放锁。 分布式锁的实现方式 数据库实现 缓存实现，比如redis zookeeper实现 未完待续 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"分布式架构","slug":"分布式架构","permalink":"http://zhangfuxin.cn/categories/分布式架构/"}],"tags":[{"name":"java","slug":"java","permalink":"http://zhangfuxin.cn/tags/java/"}],"keywords":[{"name":"分布式架构","slug":"分布式架构","permalink":"http://zhangfuxin.cn/categories/分布式架构/"}]},{"title":"分布式系统理论基础","slug":"dsbasic","date":"2018-02-26T14:31:40.000Z","updated":"2019-08-21T15:13:24.122Z","comments":true,"path":"dsbasic.html","link":"","permalink":"http://zhangfuxin.cn/dsbasic.html","excerpt":"** 分布式系统理论基础：** &lt;Excerpt in index | 首页摘要&gt;分布式系统不是万能，不能解决所有痛点。在高可用，一致性，分区容错性必须有所权衡。","text":"** 分布式系统理论基础：** &lt;Excerpt in index | 首页摘要&gt;分布式系统不是万能，不能解决所有痛点。在高可用，一致性，分区容错性必须有所权衡。 &lt;The rest of contents | 余下全文&gt; CAP理论定理：任何分布式架构都只能同时满足两点，无法三者兼顾。 Consistency（一致性），数据一致更新，所有的数据变动都是同步的。 Availability（可用性），好的响应性能。 Partition tolerance（分区容忍性）可靠性，机器宕机是否影响使用。 关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区： Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。 Consistency一致性. 在事务开始或结束时，数据库应该在一致状态。 Isolation隔离性. 事务将假定只有它自己在操作数据库，彼此不知晓。 Durability持久性 一旦事务完成，就不能返回。跨数据库两段提交事务：2PC (two-phase commit)， 2PC is the anti-scalability pattern (Pat Helland)是反可伸缩模式的，JavaEE中的JTA事务可以支持2PC。因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。 BASE理论 Basically Available 基本可用，支持分区失败 Soft state 软状态，允许状态某个时间短不同步，或者异步 Eventually consistent 最终一致性，要求数据最终结果一致，而不是时刻高度一致。 paxos协议Paxos算法的目的是为了解决分布式环境下一致性的问题。多个节点并发操纵数据，如何保证在读写过程中数据的一致性，并且解决方案要能适应分布式环境下的不可靠性（系统如何就一个值达到统一）。 Paxos的两个组件: Proposer：提议发起者，处理客户端请求，将客户端的请求发送到集群中，以便决定这个值是否可以被批准。 Acceptor:提议批准者，负责处理接收到的提议，他们的回复就是一次投票。会存储一些状态来决定是否接收一个值 Paxos有两个原则 安全原则—保证不能做错的事 a） 针对某个实例的表决只能有一个值被批准，不能出现一个被批准的值被另一个值覆盖的情况；(假设有一个值被多数Acceptor批准了，那么这个值就只能被学习) b） 每个节点只能学习到已经被批准的值，不能学习没有被批准的值。 存活原则—只要有多数服务器存活并且彼此间可以通信，最终都要做到的下列事情： a）最终会批准某个被提议的值； b）一个值被批准了，其他服务器最终会学习到这个值。 zab协议(ZooKeeper Atomic broadcast protocol)ZAB协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。 Phase 0: Leader election（选举阶段）节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。只有到达 Phase 3 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。 Phase 1: Discovery（发现阶段）在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且准 leader 生成新的 epoch，让 followers 接受，更新它们的 acceptedEpoch。一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入 Phase 0。 Phase 2: Synchronization（同步阶段）同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。只有当 quorum 都同步完成，准 leader 才会成为真正的 leader。follower 只会接收 zxid 比自己的 lastZxid 大的提议。 Phase 3: Broadcast（广播阶段）到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。 raft协议在Raft中，每个结点会处于下面三种状态中的一种： follower所有结点都以follower的状态开始。如果没收到leader消息则会变成candidate状态。 candidate会向其他结点“拉选票”，如果得到大部分的票则成为leader。这个过程就叫做Leader选举(Leader Election) leader所有对系统的修改都会先经过leader。每个修改都会写一条日志(log entry)。leader收到修改请求后的过程如下，这个过程叫做日志复制(Log Replication)： 1. 复制日志到所有follower结点(replicate entry) 2. 大部分结点响应时才提交日志 3. 通知所有follower结点日志已提交 4. 所有follower也提交日志 5. 现在整个系统处于一致的状态 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"分布式架构","slug":"分布式架构","permalink":"http://zhangfuxin.cn/categories/分布式架构/"}],"tags":[{"name":"protocol","slug":"protocol","permalink":"http://zhangfuxin.cn/tags/protocol/"}],"keywords":[{"name":"分布式架构","slug":"分布式架构","permalink":"http://zhangfuxin.cn/categories/分布式架构/"}]},{"title":"为什么使用zookeeper？","slug":"zookeeper","date":"2018-02-18T14:15:44.000Z","updated":"2019-08-21T15:13:24.148Z","comments":true,"path":"zookeeper.html","link":"","permalink":"http://zhangfuxin.cn/zookeeper.html","excerpt":"** 为什么使用zookeeper？：** &lt;Excerpt in index | 首页摘要&gt;随着大型互联网的发展，分布式系统应用越来越来越广泛，zookeeper成了分布式系统的标配。集群容错，动态负载均衡，动态扩容，异地多活等架构都依赖于zookeeper而搭建。","text":"** 为什么使用zookeeper？：** &lt;Excerpt in index | 首页摘要&gt;随着大型互联网的发展，分布式系统应用越来越来越广泛，zookeeper成了分布式系统的标配。集群容错，动态负载均衡，动态扩容，异地多活等架构都依赖于zookeeper而搭建。 &lt;The rest of contents | 余下全文&gt; zookeeper是什么？zookeeper是由雅虎创建的，基于google chubby,一个开源的分布式协调服务，是分布式数据一致性的解决方案。 zookeeper的特性 顺序一致性，从同一个客户端发起的事务请求，最终会严格按照顺序被应用到zookeeper中。 原子性，事务请求在所有集群是一致的，要么都成功，要么都失败。 可靠性，一旦服务器成功应用某个事务，那么所有集群中一定同步并保留。 实时性，一个事务被应用，客户端能立即从服务端读取到状态变化。 zookeeper的原理？基于分布式协议pasxo，而实现了自己的zab协议。保证数据的一致性。 zookeeper的数据模型 持久化节点，节点创建后一直存在，直到主动删除。 持久化有序节点，每个节点都会为它的一级子节点维护一个顺序。 临时节点，临时节点的生命周期和客户端会话保持一直。客户端会话失效，节点自动清理。 临时有序节点，临时节点基础上多一个顺序性特性。 zookeeper使用场景有哪些？ 订阅发布 watcher机制 统一配置管理(disconf) 分布式锁（redis也可以） 分布式队列 负载均衡(dubbo) ID生成器 master选举(kafka,hadoop,hbase) 集群角色有哪些？leader 事务请求的唯一调度者和处理者，保证集群事务的处理顺序 集群内部服务的调度者 follower 处理非事务请求，以及转发事务请求到leader 参与事务请求提议的投票 参与leader选举的投票 observer 观察集群中最新状态的变化并同步到observer服务器上 增加observer不影响集群事务处理能力，还能提升非事务请求的处理能力 zookeeper集群为什么是奇数？zookeeper事务请求提议需要超过半数的机器，假如是2(n+1)台,需要n+2台机器同意，由于在增删改操作中需要半数以上服务器通过，来分析以下情况。2台服务器，至少2台正常运行才行（2的半数为1，半数以上最少为2），正常运行1台服务器都不允许挂掉3台服务器，至少2台正常运行才行（3的半数为1.5，半数以上最少为2），正常运行可以允许1台服务器挂掉4台服务器，至少3台正常运行才行（4的半数为2，半数以上最少为3），正常运行可以允许1台服务器挂掉5台服务器，至少3台正常运行才行（5的半数为2.5，半数以上最少为3），正常运行可以允许2台服务器挂掉6台服务器，至少3台正常运行才行（6的半数为3，半数以上最少为4），正常运行可以允许2台服务器挂掉 zookeeper日志管理？leader选举的原理未完待续 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"分布式架构","slug":"分布式架构","permalink":"http://zhangfuxin.cn/categories/分布式架构/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://zhangfuxin.cn/tags/zookeeper/"}],"keywords":[{"name":"分布式架构","slug":"分布式架构","permalink":"http://zhangfuxin.cn/categories/分布式架构/"}]},{"title":"查找链表倒数第n个元素","slug":"descNode","date":"2018-02-16T13:45:45.000Z","updated":"2019-08-21T15:13:24.121Z","comments":true,"path":"descNode.html","link":"","permalink":"http://zhangfuxin.cn/descNode.html","excerpt":"** 查找链表倒数第n个元素：** &lt;Excerpt in index | 首页摘要&gt;链表应用很广泛，有单向链表，双向链表。单向链表如何查找倒数第n个元素呢？本文以java代码实现链表反向查找。","text":"** 查找链表倒数第n个元素：** &lt;Excerpt in index | 首页摘要&gt;链表应用很广泛，有单向链表，双向链表。单向链表如何查找倒数第n个元素呢？本文以java代码实现链表反向查找。 &lt;The rest of contents | 余下全文&gt; 单向链表的定义单向链表，主要有数据存储，下一个节点的引用这两个元素组成。 12345678public class Node &#123; int value; Node next; Node(int value) &#123; this.value = value; &#125;&#125; 遍历倒数第n个元素在查找过程中，设置两个指针，让其中一个指针比另一个指针先前移k-1步，然后两个指针同时往前移动。循环直到先行的指针指为NULL时，另一个指针所指的位置就是所要找的位置算法复杂度为o（n） 123456789101112131415161718192021222324public Node findDescEle(Node head, int k) &#123; if (k &lt; 1 || head == null) &#123; return null; &#125; Node p1 = head; Node p2 = head; //前移k-1步 int step = 0; for (int i = 0; i &lt; k; i++) &#123; step++; if (p1.next != null) &#123; p1 = p1.next; &#125; else &#123; return null; &#125; &#125; while (p1 != null) &#123; step++; p1 = p1.next; p2 = p2.next; &#125; System.out.println(&quot;o(n)==&quot; + step); return p2;&#125; 总结查找链表倒数第n个元素，复杂度为o(n),使用两个指针即可简单实现。 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"sprigmvc项目转为springboot","slug":"sprigmvc2boot","date":"2018-02-06T14:12:55.000Z","updated":"2019-08-21T15:13:24.139Z","comments":true,"path":"sprigmvc2boot.html","link":"","permalink":"http://zhangfuxin.cn/sprigmvc2boot.html","excerpt":"** sprigmvc项目转为springboot：** &lt;Excerpt in index | 首页摘要&gt;是否有老掉牙的springmvc项目，想转成springboot项目，看这个文章就对了。","text":"** sprigmvc项目转为springboot：** &lt;Excerpt in index | 首页摘要&gt;是否有老掉牙的springmvc项目，想转成springboot项目，看这个文章就对了。 &lt;The rest of contents | 余下全文&gt; 说明 如果你的项目连maven项目都不是，请自行转为maven项目，在按照本教程进行。 本教程适用于spring+springmvc+mybatis+shiro的maven项目。 1.修改pom文件依赖 删除之前的spring依赖，添加springboot依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 这个是剔除掉自带的 tomcat部署的--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- tomcat容器部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;!--&lt;scope&gt;compile&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- 支持 @ConfigurationProperties 注解 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加springboot构建插件 12345678910111213141516171819202122&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;&lt;/plugins&gt; 2.添加application启动文件注意，如果Application在controller，service，dao的上一层包里，无需配置@ComponentScan,否则，需要指明要扫描的包。 12345678910111213@SpringBootApplication//@ComponentScan(&#123;\"com.cms.controller\",\"com.cms.service\",\"com.cms.dao\"&#125;)public class Application extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(Application.class); &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Application.class, args); &#125;&#125; 3.添加springboot配置文件 在resources下面添加application.properties文件 添加基本配置1234567891011121314151617#默认前缀server.contextPath=/# 指定环境spring.profiles.active=local# jsp配置spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp#log配置文件logging.config=classpath:logback-cms.xml#log路径logging.path=/Users/mac/work-tommy/cms-springboot/logs/#数据源spring.datasource.name=adminDataSourcespring.datasource.driverClassName = com.mysql.jdbc.Driverspring.datasource.url = jdbc:mysql://localhost:3306/mycms?useUnicode=true&amp;autoReconnect=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = 123456 4.使用@Configuration注入配置 注入mybatis配置,分页插件请自主选择 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Configuration@MapperScan(basePackages = \"com.kuwo.dao\",sqlSessionTemplateRef = \"adminSqlSessionTemplate\")public class AdminDataSourceConfig &#123; @Bean(name = \"adminDataSource\") @ConfigurationProperties(prefix = \"spring.datasource\") @Primary public DataSource adminDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = \"adminSqlSessionFactory\") @Primary public SqlSessionFactory adminSqlSessionFactory(@Qualifier(\"adminDataSource\") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); //分页插件// PageHelper pageHelper = new PageHelper(); PagePlugin pagePlugin = new PagePlugin();// Properties props = new Properties();// props.setProperty(\"reasonable\", \"true\");// props.setProperty(\"supportMethodsArguments\", \"true\");// props.setProperty(\"returnPageInfo\", \"check\");// props.setProperty(\"params\", \"count=countSql\");// pageHelper.setProperties(props); //添加插件 bean.setPlugins(new Interceptor[]&#123;pagePlugin&#125;); // 添加mybatis配置文件 bean.setConfigLocation(new DefaultResourceLoader().getResource(\"classpath:mybatis/mybatis-config.xml\")); // 添加mybatis映射文件 bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mybatis/system/*.xml\")); return bean.getObject(); &#125; @Bean(name = \"adminTransactionManager\") @Primary public DataSourceTransactionManager adminTransactionManager(@Qualifier(\"adminDataSource\") DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; @Bean(name = \"adminSqlSessionTemplate\") @Primary public SqlSessionTemplate adminSqlSessionTemplate(@Qualifier(\"adminSqlSessionFactory\") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 添加Interceptor配置,注意addInterceptor的顺序，不要搞乱了 1234567@Configurationpublic class InterceptorConfiguration extends WebMvcConfigurerAdapter&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()); &#125;&#125; 添加shiro配置文件 注意：本来使用redis做session缓存，但是和shiro集成发现一个问题，user对象存储以后，从shiro中获取后，无法进行类型转换，所以暂时放弃了redis做session缓存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140@Configurationpublic class ShiroConfiguration &#123; @Value(\"$&#123;spring.redis.host&#125;\") private String host; @Value(\"$&#123;spring.redis.port&#125;\") private int port; @Value(\"$&#123;spring.redis.timeout&#125;\") private int timeout; @Bean public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125; /** * ShiroFilterFactoryBean 处理拦截资源文件问题。 * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，因为在 * 初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager * Filter Chain定义说明 1、一个URL可以配置多个Filter，使用逗号分隔 2、当设置多个过滤器时，全部验证通过，才视为通过 3、部分过滤器可指定参数，如perms，roles * */ @Bean public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager)&#123; System.out.println(\"ShiroConfiguration.shirFilter()\"); ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean.setSecurityManager(securityManager); // 如果不设置默认会自动寻找Web工程根目录下的\"/login.jsp\"页面 shiroFilterFactoryBean.setLoginUrl(\"/login_toLogin\"); // 登录成功后要跳转的链接 shiroFilterFactoryBean.setSuccessUrl(\"/usersPage\"); //未授权界面; shiroFilterFactoryBean.setUnauthorizedUrl(\"/403\"); //拦截器. Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); //配置退出 过滤器,其中的具体的退出代码Shiro已经替我们实现了 filterChainDefinitionMap.put(\"/logout\", \"logout\"); filterChainDefinitionMap.put(\"/login_toLogin\", \"anon\"); filterChainDefinitionMap.put(\"/login_login\", \"anon\"); filterChainDefinitionMap.put(\"/static/login/**\",\"anon\"); filterChainDefinitionMap.put(\"/static/js/**\",\"anon\"); filterChainDefinitionMap.put(\"/uploadFiles/uploadImgs/**\",\"anon\"); filterChainDefinitionMap.put(\"/code.do\",\"anon\"); filterChainDefinitionMap.put(\"/font-awesome/**\",\"anon\"); //&lt;!-- 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 --&gt;:这是一个坑呢，一不小心代码就不好使了; //&lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&gt; filterChainDefinitionMap.put(\"/**\", \"authc\"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; &#125; @Bean public SecurityManager securityManager()&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); //设置realm. securityManager.setRealm(myShiroRealm()); // 自定义缓存实现 使用redis //securityManager.setCacheManager(cacheManager()); // 自定义session管理 使用redis securityManager.setSessionManager(sessionManager()); return securityManager; &#125; @Bean public ShiroRealm myShiroRealm()&#123; ShiroRealm myShiroRealm = new ShiroRealm();// myShiroRealm.setCredentialsMatcher(hashedCredentialsMatcher()); return myShiroRealm; &#125;&#125; /** * 开启shiro aop注解支持. * 使用代理方式;所以需要开启代码支持; * @param securityManager * @return */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager)&#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; &#125; /** * 配置shiro redisManager * 使用的是shiro-redis开源插件 * @return */ public RedisManager redisManager() &#123; RedisManager redisManager = new RedisManager(); redisManager.setHost(host); redisManager.setPort(port); redisManager.setExpire(1800); redisManager.setTimeout(timeout); // redisManager.setPassword(password); return redisManager; &#125; /** * cacheManager 缓存 redis实现 * 使用的是shiro-redis开源插件 * @return */ public RedisCacheManager cacheManager() &#123; RedisCacheManager redisCacheManager = new RedisCacheManager(); redisCacheManager.setRedisManager(redisManager()); return redisCacheManager; &#125; /** * RedisSessionDAO shiro sessionDao层的实现 通过redis * 使用的是shiro-redis开源插件 */ @Bean public RedisSessionDAO redisSessionDAO() &#123; RedisSessionDAO redisSessionDAO = new RedisSessionDAO(); redisSessionDAO.setRedisManager(redisManager()); return redisSessionDAO; &#125; @Bean public DefaultWebSessionManager sessionManager() &#123; DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();// sessionManager.setSessionDAO(redisSessionDAO()); return sessionManager; &#125;&#125; 总结搞了一天时间把项目转成springboot，查阅各种资料，希望这篇文章能够为你带来帮助。 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://zhangfuxin.cn/categories/项目实战/"}],"tags":[{"name":"java","slug":"java","permalink":"http://zhangfuxin.cn/tags/java/"}],"keywords":[{"name":"项目实战","slug":"项目实战","permalink":"http://zhangfuxin.cn/categories/项目实战/"}]},{"title":"mybatis-generator","slug":"mybatis-generator","date":"2018-01-28T09:30:19.000Z","updated":"2019-08-21T15:13:24.131Z","comments":true,"path":"mybatis-generator.html","link":"","permalink":"http://zhangfuxin.cn/mybatis-generator.html","excerpt":"** mybatis-generator：** &lt;Excerpt in index | 首页摘要&gt;mybatis反向生成器，根据数据库表，自动创建pojo，mapper以及mybatis配置文件，能极大的提高开发效率。","text":"** mybatis-generator：** &lt;Excerpt in index | 首页摘要&gt;mybatis反向生成器，根据数据库表，自动创建pojo，mapper以及mybatis配置文件，能极大的提高开发效率。 &lt;The rest of contents | 余下全文&gt; 插件介绍本插件fork自mybatis-generator-gui,在此基础上加了批量生成表。 插件特性 保存数据库配置 根据表生成pojo，mapper以及mybatis配置文件 批量生成 其它功能（待开发） 插件使用要求本工具由于使用了Java 8的众多特性，所以要求JDK 1.8.0.60以上版本，对于JDK版本还没有升级的童鞋表示歉意。 启动本软件 方法一: 自助构建 12345git clone https://github.com/maochunguang/mybatis-generator-guicd mybatis-generator-guimvn jfx:jarcd target/jfx/app/java -jar mybatis-generator-gui.jar 方法二: IDE中运行Eclipse or IntelliJ IDEA中启动, 找到com.zzg.mybatis.generator.MainUI类并运行就可以了 文档更多详细文档请参考本库的Wiki Usage 截图参考 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://zhangfuxin.cn/tags/mysql/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}]},{"title":"突破算法第11天-红黑树","slug":"suanfa-11","date":"2017-10-30T14:35:37.000Z","updated":"2019-08-21T15:13:24.142Z","comments":true,"path":"suanfa-11.html","link":"","permalink":"http://zhangfuxin.cn/suanfa-11.html","excerpt":"** 突破算法第11天-红黑树：** &lt;Excerpt in index | 首页摘要&gt;红黑树","text":"** 突破算法第11天-红黑树：** &lt;Excerpt in index | 首页摘要&gt;红黑树 &lt;The rest of contents | 余下全文&gt; 红黑树本文的主要内容： 红黑树的基本概念以及最重要的 5 点规则。 红黑树的左旋转、右旋转、重新着色的原理与 Java 实现； 红黑树的增加结点、删除结点过程解析； 红黑树的基本概念与数据结构表示首先红黑树来个定义： 红黑树定义：红黑树又称红 - 黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树 (平衡二叉树的一种实现方式)。 我们知道一颗基本的二叉排序树他们都需要满足一个基本性质：即树中的任何节点的值大于它的左子节点，且小于它的右子节点。 按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉排序树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右 / 左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉排序树的平衡，大牛们提出了各种平衡二叉树的实现算法，如：AVL，SBT，伸展树，TREAP ，红黑树等等。 平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个子节点，其左右子树的高度都相近。下面给出平衡二叉树的几个示意图： 红黑树顾名思义就是结点是红色或者是黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树而言我们必须增加如下规则，这也是红黑树最重要的 5 点规则： 每个结点都只能是红色或者黑色中的一种。 根结点是黑色的。 每个叶结点（NIL 节点，空节点）是黑色的。 如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。 这些约束强制了红黑树的关键性质: 从根到叶子最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。所以红黑树它是复杂而高效的，其检索效率 O(lg n)。下图为一颗典型的红黑二叉树： 上面关于红黑树的概念基本已经说得很清楚了，下面给出红黑树的结点用 Java 表示数据结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static final boolean RED = true;private static final boolean BLACK = false;private Node root;//二叉查找树的根节点//结点数据结构private class Node&#123; private Key key;//键 private Value value;//值 private Node left, right;//指向子树的链接:左子树和右子树. private int N;//以该节点为根的子树中的结点总数 boolean color;//由其父结点指向它的链接的颜色也就是结点颜色. public Node(Key key, Value value, int N, boolean color) &#123; this.key = key; this.value = value; this.N = N; this.color = color; &#125;&#125;/** * 获取整个二叉查找树的大小 * @return */public int size()&#123; return size(root);&#125;/** * 获取某一个结点为根结点的二叉查找树的大小 * @param x * @return */private int size(Node x)&#123; if(x == null)&#123; return 0; &#125; else &#123; return x.N; &#125;&#125;private boolean isRed(Node x)&#123; if(x == null)&#123; return false; &#125; return x.color == RED;&#125; 红黑树的三个基本操作红黑树在插入，删除过程中可能会破坏原本的平衡条件导致不满足红黑树的性质，这时候一般情况下要通过左旋、右旋和重新着色这个三个操作来使红黑树重新满足平衡化条件。 旋转旋转分为左旋和右旋。在我们实现某些操作中可能会出现红色右链接或则两个连续的红链接，这时候就要通过旋转修复。 通常左旋操作用于将一个向右倾斜的红色链接 (这个红色链接链连接的两个结点均是红色结点) 旋转为向左链接。对比操作前后，可以看出，该操作实际上是将红线链接的两个结点中的一个较大的结点移动到根结点上。 左旋的示意图如下： 左旋的 Java 实现如下： 12345678910111213141516171819/** * 左旋转 * @param h * @return */private Node rotateLeft(Node h)&#123; Node x = h.right; //把x的左结点赋值给h的右结点 h.right = x.left; //把h赋值给x的左结点 x.left = h; // x.color = h.color; h.color = RED; x.N = h.N; h.N = 1+ size(h.left) + size(h.right); return x;&#125; 左旋的动画效果如下： 右旋其实就是左旋的逆操作：右旋的代码如下： 12345678910111213141516/** * 右旋转 * @param h * @return */private Node rotateRight(Node h)&#123; Node x = h.left; h.left = x.right; x.right = h; x.color = h.color; h.color = RED; x.N = h.N; h.N = 1+ size(h.left) + size(h.right); return x;&#125; 右旋的动态示意图： 颜色反转当出现一个临时的 4-node 的时候，即一个节点的两个子节点均为红色，如下图：我们需要将 E 提升至父节点，操作方法很简单，就是把 E 对子节点的连线设置为黑色，自己的颜色设置为红色。颜色反转之后颜色如下：实现代码如下： 123456789/** * 颜色转换 * @param h */private void flipColors(Node h)&#123; h.color = RED;//父结点颜色变红 h.left.color = BLACK;//子结点颜色变黑 h.right.color = BLACK;//子结点颜色变黑&#125; 注意：以上的旋转和颜色反转操作都是针对单一结点的，反转或则颜色反转操作之后可能引起其父结点又不满足平衡性质。 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"突破算法第10天-二叉树","slug":"suanfa-10","date":"2017-10-29T13:17:09.000Z","updated":"2019-08-21T15:13:24.141Z","comments":true,"path":"suanfa-10.html","link":"","permalink":"http://zhangfuxin.cn/suanfa-10.html","excerpt":"** 突破算法第10天-二叉树：** &lt;Excerpt in index | 首页摘要&gt;用java实现算法求出二叉树的高度","text":"** 突破算法第10天-二叉树：** &lt;Excerpt in index | 首页摘要&gt;用java实现算法求出二叉树的高度 &lt;The rest of contents | 余下全文&gt; 树 先序遍历：先访问根结点，然后左节点，最后右节点 中序遍历：先访问左结点，然后根节点，最后右节点 后续遍历：先访问左结点，然后右节点，最后根节点 java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class TreeNode &#123; TreeNode left; TreeNode right; int val; TreeNode(int val) &#123; this.val = val; &#125; public static void main(String[] args) &#123; TreeNode root = new TreeNode(1); TreeNode left1 = new TreeNode(2); TreeNode left2 = new TreeNode(3); TreeNode right1 = new TreeNode(4); //创建一棵树 root.left = left1; left1.right = left2; root.right = right1; scanNodes(root); System.out.println(\"树的深度是：\" + getDepth(root)); System.out.println(\"非递归深度：\" + findDeep2(root)); &#125; // 递归返回二叉树的深度 static int getDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = getDepth(root.left); int right = getDepth(root.right); return left &gt; right ? left + 1 : right + 1; &#125; static void scanNodes(TreeNode root) &#123; if (root == null) &#123; return; &#125;// System.out.println(root.val); //先序遍历 scanNodes(root.left);// System.out.println(root.val); //中序遍历 scanNodes(root.right); System.out.println(root.val); // 后序遍历 &#125; // 非递归求深度 public static int findDeep2(TreeNode root) &#123; if (root == null) return 0; TreeNode current = null; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int cur, next; int level = 0; while (!queue.isEmpty()) &#123; cur = 0; //当遍历完当前层以后，队列里元素全是下一层的元素，队列的长度是这一层的节点的个数 next = queue.size(); while (cur &lt; next) &#123; current = queue.poll(); cur++; //把当前节点的左右节点入队（如果存在的话） if (current.left != null) &#123; queue.offer(current.left); &#125; if (current.right != null) &#123; queue.offer(current.right); &#125; &#125; level++; &#125; return level; &#125;&#125; 树的变种二叉查找树，平衡二叉查找树，红黑树，b树红黑树和平衡二叉树（AVL树）类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。红黑树和AVL树的区别在于它使用颜色来标识结点的高度，它所追求的是局部平衡而不是AVL树中的非常严格的平衡。由于二叉树的效率和深度息息相关，于是出现了多路的B树，B+树等等。b树是叶子为n的平衡树。 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"突破算法第九天-排序算法比较","slug":"suanfa-9","date":"2017-10-28T15:10:58.000Z","updated":"2019-08-21T15:13:24.146Z","comments":true,"path":"suanfa-9.html","link":"","permalink":"http://zhangfuxin.cn/suanfa-9.html","excerpt":"** 突破算法第九天-排序算法比较：** &lt;Excerpt in index | 首页摘要&gt;排序算法个有千秋，有的性能高，有的性能很低。这就要求我们对常用的排序算法要全面了解，不要用错了算法，导致性能问题。","text":"** 突破算法第九天-排序算法比较：** &lt;Excerpt in index | 首页摘要&gt;排序算法个有千秋，有的性能高，有的性能很低。这就要求我们对常用的排序算法要全面了解，不要用错了算法，导致性能问题。 &lt;The rest of contents | 余下全文&gt; 排序算法性能比较·借一张网路上的比较图。特别直观。 \b\b排序算法总结个人看法： 一般的情况还是以快速排序为主， 对于多个有序的数组合并的情况使用归并排序 性能要求快，空间足够，待排序的元素都要在一定的范围内使用桶排序 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"突破算法第八天-桶排序","slug":"suanfa-8","date":"2017-10-27T14:51:06.000Z","updated":"2019-08-21T15:13:24.145Z","comments":true,"path":"suanfa-8.html","link":"","permalink":"http://zhangfuxin.cn/suanfa-8.html","excerpt":"** 突破算法第八天-桶排序：** &lt;Excerpt in index | 首页摘要&gt;桶排序是个神奇的排序，在某些情况下可以达到O(N)的复杂度，快的离谱。但是桶排序是利用空间换时间，在空间充足的情况下，可以用桶排序进行高效的排序。","text":"** 突破算法第八天-桶排序：** &lt;Excerpt in index | 首页摘要&gt;桶排序是个神奇的排序，在某些情况下可以达到O(N)的复杂度，快的离谱。但是桶排序是利用空间换时间，在空间充足的情况下，可以用桶排序进行高效的排序。 &lt;The rest of contents | 余下全文&gt; 桶排序的基本原理将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(nlogn) 下限的影响， 简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序 桶排序的java实现12345678910111213141516171819202122232425262728293031323334353637383940414243public static void bucketSort1(int[] arr)&#123; //分桶，这里采用映射函数f(x)=x/10。 int bucketCount =10; Integer[][] bucket = new Integer[bucketCount][arr.length]; for (int i=0; i&lt;arr.length; i++)&#123; int quotient = arr[i]/10; for (int j=0; j&lt;arr.length; j++)&#123; if (bucket[quotient][j]==null)&#123; bucket[quotient][j]=arr[i]; break; &#125; &#125; &#125; //小桶排序 for (int i=0; i&lt;bucket.length; i++)&#123; //insertion sort for (int j=1; j&lt;bucket[i].length; ++j)&#123; if(bucket[i][j]==null)&#123; break; &#125; int value = bucket[i][j]; int position=j; while (position&gt;0 &amp;&amp; bucket[i][position-1]&gt;value)&#123; bucket[i][position] = bucket[i][position-1]; position--; &#125; bucket[i][position] = value; &#125; &#125; //输出 for (int i=0, index=0; i&lt;bucket.length; i++)&#123; for (int j=0; j&lt;bucket[i].length; j++)&#123; if (bucket[i][j]!=null)&#123; arr[index] = bucket[i][j]; index++; &#125; else&#123; break; &#125; &#125; &#125; &#125; 算法复杂度前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是： 首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。 其次待排序的元素都要在一定的范围内，限制较多。 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"突破算法第七天-堆排序","slug":"suanfa-7","date":"2017-10-26T14:50:57.000Z","updated":"2019-08-21T15:13:24.145Z","comments":true,"path":"suanfa-7.html","link":"","permalink":"http://zhangfuxin.cn/suanfa-7.html","excerpt":"** 突破算法第七天-堆排序：** &lt;Excerpt in index | 首页摘要&gt;堆排序是利用二叉树的原理实现的一种排序，难点在于要构建堆,构建堆一般可以采用下沉或者上浮的算法进行。","text":"** 突破算法第七天-堆排序：** &lt;Excerpt in index | 首页摘要&gt;堆排序是利用二叉树的原理实现的一种排序，难点在于要构建堆,构建堆一般可以采用下沉或者上浮的算法进行。 &lt;The rest of contents | 余下全文&gt; 堆排序的基本原理初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。因此，实现堆排序需解决两个问题： 如何将n 个待排序的数建成堆； 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。 堆排序java实现1234567891011121314151617181920212223242526272829303132public static void sort(int[] a) &#123; int n = a.length; for (int k = n / 2; k &gt;= 1; k--) sink(a, k, n); while (n &gt; 1) &#123; swap(a, 1, n--); sink(a, 1, n); &#125; &#125;private static void sink(int[] a, int k, int n) &#123; while (2 * k &lt;= n) &#123; int j = 2 * k; if (j &lt; n &amp;&amp; a[j - 1] &lt; a[j + 1 - 1]) j++; if (a[k - 1] &gt;= a[j - 1]) break; swap(a, k, j); k = j; &#125;&#125;private static void swap(int[] a, int i, int j) &#123; int swap = a[i - 1]; a[i - 1] = a[j - 1]; a[j - 1] = swap;&#125;public static void main(String[] args) &#123; int[] arr = &#123;49, 38, 65, 97, 76, 13, 27, 4, 78, 34, 12, 64, 1, 8&#125;; sort(arr); System.out.println(\"排序之后：\"); System.out.println(Arrays.toString(arr));&#125; 算法复杂度堆排序的平均时间复杂度为Ο(nlogn) 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"突破算法第六天-冒泡排序","slug":"suanfa-6","date":"2017-10-25T14:06:06.000Z","updated":"2019-08-21T15:13:24.144Z","comments":true,"path":"suanfa-6.html","link":"","permalink":"http://zhangfuxin.cn/suanfa-6.html","excerpt":"** 突破算法第六天-冒泡排序：** &lt;Excerpt in index | 首页摘要&gt;冒泡排序也非常简单，效率比较低。了解即可。","text":"** 突破算法第六天-冒泡排序：** &lt;Excerpt in index | 首页摘要&gt;冒泡排序也非常简单，效率比较低。了解即可。 &lt;The rest of contents | 余下全文&gt; 冒泡排序的原理在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 冒泡排序的java实现1234567891011private static void bubbleSort(int a[], int n) &#123; for (int i = 0; i &lt; n - 1; ++i) &#123; for (int j = 0; j &lt; n - i - 1; ++j) &#123; if (a[j] &gt; a[j + 1]) &#123; int tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; &#125; &#125; &#125;&#125; 算法复杂度冒泡排序的复杂度为O(n^2) 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"突破算法第五天-选择排序","slug":"suanfa-5","date":"2017-10-24T13:46:33.000Z","updated":"2019-08-21T15:13:24.144Z","comments":true,"path":"suanfa-5.html","link":"","permalink":"http://zhangfuxin.cn/suanfa-5.html","excerpt":"** 突破算法第五天-选择排序：** &lt;Excerpt in index | 首页摘要&gt;选择排序很简单，属于交换排序算法。通过比较找到最大值或最小值，然后进行交换。","text":"** 突破算法第五天-选择排序：** &lt;Excerpt in index | 首页摘要&gt;选择排序很简单，属于交换排序算法。通过比较找到最大值或最小值，然后进行交换。 &lt;The rest of contents | 余下全文&gt; 选择排序的原理首先找到数组中最小的元素，与数组第一个元素交换，然后在剩下的元素中选择最小的，与第二个元素交换，以此类推，直到排序完成。 选择排序的java实现1234567891011121314private static void sort(int[] a) &#123; int len = a.length; for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; (a[j] &lt; a[j - 1]); j--) &#123; swap(a, j, j - 1); &#125; &#125;&#125;private static void swap(int[] a, int i, int j) &#123; int swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; 算法复杂度选择排序的算法复杂度是O(n^2) 改进 每次选择的时候把最大值和最小值都比较出来，双向进行交换排序 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"突破算法第一天-归并排序","slug":"suanfa-4","date":"2017-10-23T15:56:27.000Z","updated":"2019-08-21T15:13:24.143Z","comments":true,"path":"suanfa-4.html","link":"","permalink":"http://zhangfuxin.cn/suanfa-4.html","excerpt":"** 突破算法第一天-归并排序：** &lt;Excerpt in index | 首页摘要&gt;归并排序是利用分治思想进行排序的典型应用，特别是对几个基本有序的子序列合并时，效率最高。在实际应用中，分布式应用，分布式查询排序会比较多应用到归并排序。","text":"** 突破算法第一天-归并排序：** &lt;Excerpt in index | 首页摘要&gt;归并排序是利用分治思想进行排序的典型应用，特别是对几个基本有序的子序列合并时，效率最高。在实际应用中，分布式应用，分布式查询排序会比较多应用到归并排序。 &lt;The rest of contents | 余下全文&gt; 归并排序的原理归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。归并排序分为两种种，第一种是自底向上的归并。 第二种是自顶向下的归并。 自底向上的归并排序java实现1234567891011121314151617181920212223242526272829303132333435public class MergeSortBU &#123; private static void merge(int[] a, int[] aux, int lo, int mid, int hi) &#123; // 复制到aux[] for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; // 合并回 a[] int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (aux[j] &lt; aux[i]) a[k] = aux[j++]; else a[k] = aux[i++]; &#125; &#125; public static void mergeSort(int[] a) &#123; int n = a.length; int[] aux = new int[n]; for (int len = 1; len &lt; n; len *= 2) &#123; for (int lo = 0; lo &lt; n - len; lo += len + len) &#123; int mid = lo + len - 1; int hi = Math.min(lo + len + len - 1, n - 1); merge(a, aux, lo, mid, hi); &#125; &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123;49, 38, 65, 97, 76, 13, 27, 4, 78, 34, 12, 64, 1, 8&#125;; mergeSort(arr); System.out.println(\"排序之后：\"); System.out.println(Arrays.toString(arr)); &#125;&#125; 自顶向下的归并排序java实现1234567891011121314151617181920212223private static void sort(int[] a, int low, int high) &#123; if (high &lt;= low) return; int mid = low + (high - low) / 2; sort(a, low, mid); sort(a, mid + 1, high); merge(a, low, mid, high); &#125; private static void merge(int[] a, int lo, int mid, int hi) &#123; // 复制到aux[] int[] aux = new int[a.length]; for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; // 合并回 a[] int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (aux[j] &lt; aux[i]) a[k] = aux[j++]; else a[k] = aux[i++]; &#125; &#125; 算法复杂度归并排序的算法复杂度是nlgn 应用场景 几个基本有序的数组进行排序 部分有序的数组 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"突破算法第三天-希尔排序","slug":"suanfa-3","date":"2017-10-22T13:51:03.000Z","updated":"2019-08-21T15:13:24.143Z","comments":true,"path":"suanfa-3.html","link":"","permalink":"http://zhangfuxin.cn/suanfa-3.html","excerpt":"** 突破算法第三天-希尔排序：** &lt;Excerpt in index | 首页摘要&gt;希尔排序平常用的比较少，主要是基于插入排序的改进。但是希尔排序的性能很高，数组越大，性能优势越明显。","text":"** 突破算法第三天-希尔排序：** &lt;Excerpt in index | 首页摘要&gt;希尔排序平常用的比较少，主要是基于插入排序的改进。但是希尔排序的性能很高，数组越大，性能优势越明显。 &lt;The rest of contents | 余下全文&gt; 希尔排序的基本原理基本思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。操作方法： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 希尔排序java实现12345678910111213141516171819public static void shellSort(int[] a) &#123; int n = a.length; int h = 1; while (h &lt; n/3) h = 3*h + 1; while (h &gt;= 1) &#123; // h-sort the array for (int i = h; i &lt; n; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; (a[j]&lt; a[j-h]); j -= h) &#123; swap(a, j, j-h); &#125; &#125; h /= 3; &#125;&#125;private static void swap(int[] a, int i, int j) &#123; int swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; 算法复杂度希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，是一个不稳定排序算法 适用场景 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"突破算法第二天-插入排序","slug":"suanfa-2","date":"2017-10-21T01:41:27.000Z","updated":"2019-08-21T15:13:24.142Z","comments":true,"path":"suanfa-2.html","link":"","permalink":"http://zhangfuxin.cn/suanfa-2.html","excerpt":"** 突破算法第二天-插入排序：** &lt;Excerpt in index | 首页摘要&gt;今天是突破算法第二天，插入排序，比较简单。效率比较低，但是思想很广泛，应用很广，是很多高级排序算法的一个子过程。","text":"** 突破算法第二天-插入排序：** &lt;Excerpt in index | 首页摘要&gt;今天是突破算法第二天，插入排序，比较简单。效率比较低，但是思想很广泛，应用很广，是很多高级排序算法的一个子过程。 &lt;The rest of contents | 余下全文&gt; 插入排序的原理 将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录 看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。 要点：设立哨兵，作为临时存储和判断数组边界之用 插入排序java实现123456789101112public static void insertSort(int[] a, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; (a[j]&lt;a[j-1]); j--) &#123; swap(a, j, j-1); &#125; &#125; &#125; private static void swap(int[] a, int i, int j) &#123; int swap = a[i]; a[i] = a[j]; a[j] = swap; &#125; 算法复杂度插入排序的复杂度为O（n^2） 改进方法希尔排序，其他的插入排序有二分插入排序，2-路插入排序。 适用场景插入排序比较适合部分有序的数组（以下四种数组） 数组中每个元素距离它的最终位置都不远 一个有序的大数组接一个小数组 数组中只有几个位置不正确 数组比较小 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"突破算法第一天-快速排序","slug":"suanfa-1","date":"2017-10-20T15:46:59.000Z","updated":"2019-08-21T15:13:24.141Z","comments":true,"path":"suanfa-1.html","link":"","permalink":"http://zhangfuxin.cn/suanfa-1.html","excerpt":"** 突破算法第一天-快速排序：** &lt;Excerpt in index | 首页摘要&gt;30天突破算法是我给自己定的一个学习计划，希望在这30天，每天都能完成计划。第一天学习最重要的快速排序。","text":"** 突破算法第一天-快速排序：** &lt;Excerpt in index | 首页摘要&gt;30天突破算法是我给自己定的一个学习计划，希望在这30天，每天都能完成计划。第一天学习最重要的快速排序。 &lt;The rest of contents | 余下全文&gt; 30天突破算法算法种类不计其数，说30天突破只是给自己定的学习计划。目的是通过30天的记录熟悉常见的算法，提高自己的算法能力。对以后的工作来说也是打下夯实的基础。 快速排序的原理快速排序也是分治法思想的一种实现，他的思路是使数组中的每个元素与基准值（Pivot，通常是数组的首个值，A[0]）比较，数组中比基准值小的放在基准值的左边，形成左部；大的放在右边，形成右部；接下来将左部和右部分别递归地执行上面的过程：选基准值，小的放在左边，大的放在右边。重复此过程，直到排序结束。步骤如下： 1.找基准值，设Pivot = a[0] 2.分区（Partition）：比基准值小的放左边，大的放右边，基准值(Pivot)放左部与右部的之间。 3.进行左部（a[0] - a[pivot-1]）的递归，以及右部（a[pivot+1] - a[n-1]）的递归，重复上述步骤。 快速排序java实现（递归版）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class QuickSort &#123; public static void main(String[] args) &#123; int[] a=&#123;49,38,65,97,76,13,27,49,78,34,12,64,1,8&#125;; System.out.println(\"排序之前：\"); for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i]+\" \"); &#125; //快速排序 quick(a); System.out.println(); System.out.println(\"排序之后：\"); for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i]+\" \"); &#125; &#125; private static void quick(int[] a) &#123; if(a.length&gt;0)&#123; quickSort(a,0,a.length-1); &#125; &#125; private static void quickSort(int[] a, int low, int high) &#123; if(low&lt;high)&#123; //如果不加这个判断递归会无法退出导致堆栈溢出异常 int middle = getMiddle(a,low,high); quickSort(a, 0, middle-1); quickSort(a, middle+1, high); &#125; &#125; private static int getMiddle(int[] a, int low, int high) &#123; int temp = a[low];//基准元素 while(low&lt;high)&#123; //找到比基准元素小的元素位置 while(low&lt;high &amp;&amp; a[high]&gt;=temp)&#123; high--; &#125; a[low] = a[high]; while(low&lt;high &amp;&amp; a[low]&lt;=temp)&#123; low++; &#125; a[high] = a[low]; &#125; a[low] = temp; return low; &#125;&#125; 快速排序三向切分法（改进的实现）12345678910111213141516171819private static void quick3Sort(int[] a, int low, int high) &#123; if (low &gt;= high) return; int lt = low, gt = high; int temp = a[low]; int i = low; while (i &lt;= gt) &#123; if (a[i] &lt; temp) swap(a, lt++, i++); else if (a[i] &gt; temp) swap(a, i, gt--); else i++; &#125; quick3Sort(a, low, lt - 1); quick3Sort(a, gt + 1, high);&#125;private static void swap(int[] a, int i, int j) &#123; int swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; 快速排序的复杂度时间复杂度 nlogn,排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。快速排序是一个不稳定的排序方法。 改进方法 当数组比较小的时候，快速排序比插入排序慢，这个时候用插入排序替换比较好。 通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录 适用场景 普通的无序集合排序，使用快速排序。 包含很多重复元素的集合排序，使用三向切分的快速排序。 基本有序的集合使用归并排序。 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"学习计划-30天突破算法","slug":"study-plan","date":"2017-10-18T11:47:55.000Z","updated":"2019-08-21T15:13:24.140Z","comments":true,"path":"study-plan.html","link":"","permalink":"http://zhangfuxin.cn/study-plan.html","excerpt":"** 学习计划-30天突破算法：** &lt;Excerpt in index | 首页摘要&gt;作为一个非专业出身的程序员，一直对算法的学习赶紧断断续续，终于下定决心对算法做一次详细总结。30天时间把程序员常用算法逐一突破。这次计划更是对自己的一次挑战，希望自己能坚持到最后！","text":"** 学习计划-30天突破算法：** &lt;Excerpt in index | 首页摘要&gt;作为一个非专业出身的程序员，一直对算法的学习赶紧断断续续，终于下定决心对算法做一次详细总结。30天时间把程序员常用算法逐一突破。这次计划更是对自己的一次挑战，希望自己能坚持到最后！ &lt;The rest of contents | 余下全文&gt; 学习排序算法的意义 学会比较算法的性能的方法 相关的排序能解决类似的问题 排序算法很多时候是解决问题的第一步 排序算法 快速排序 插入排序 希尔排序 归并排序 选择排序 冒泡排序 堆排序 桶排序 排序算法比较 树 二叉树高度和二叉树的遍历 红黑树 b树 查找算法 二分查找 二叉查找树 平衡查找树 散列表 算法思想 递归（普通递归，尾递归） 动态规划 贪婪算法 分治法 图的算法 深度优先 广度优先 最小生成树 最短路径 字符串算法 字符串查找 单词查找树 子字符串查找 典型算法分析 拓扑排序 关键路径排序 遗传算法 RSA算法 英语技术文档阅读突破 熟悉常用技术词汇 阅读常见的技术文档（官网文档看一遍） 记住常用的词汇 阅读英文技术书籍 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/categories/算法/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/tags/algorithm/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/categories/算法/"}]},{"title":"用java将GBK工程转为uft8","slug":"trandsferProject","date":"2017-08-11T23:43:59.000Z","updated":"2019-08-21T15:13:24.146Z","comments":true,"path":"trandsferProject.html","link":"","permalink":"http://zhangfuxin.cn/trandsferProject.html","excerpt":"** 用java将GBK工程转为uft8：** &lt;Excerpt in index | 首页摘要&gt;windows下的默认编码为GBK还有gb2312，如何把gbk的java工程转为utf8的呢，如果直接修改工程编码，其实里面的java文件中中文是会乱码的，写了个批量转换java工程的程序，消遣一下。","text":"** 用java将GBK工程转为uft8：** &lt;Excerpt in index | 首页摘要&gt;windows下的默认编码为GBK还有gb2312，如何把gbk的java工程转为utf8的呢，如果直接修改工程编码，其实里面的java文件中中文是会乱码的，写了个批量转换java工程的程序，消遣一下。 &lt;The rest of contents | 余下全文&gt; 为什么要转码？有些老的项目，或者朋友的项目之前没注意在windows上不是utf8，而你有需要看注释或者什么，总不能一个文件一个文件的去改编码属性吧。 本程序试用范围gbk的代码，或者gb2312的工程均可以转换 编码转换的思路本来想做成一个通用的会自动检测编码，自动转换的程序。但是由于判断编码类型不准，所以做成了针对GBK的转换。 制定gbk编码把文件流读进来，加载到内存，转为String类型的内容 将String内容转为utf8的String 将String内容写入文件 核心代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class TransferProject &#123; public static void transferFile(String pathName, int depth) throws Exception &#123; File dirFile = new File(pathName); if (!isValidFile(dirFile)) return; //获取此目录下的所有文件名与目录名 String[] fileList = dirFile.list(); int currentDepth = depth + 1; for (int i = 0; i &lt; fileList.length; i++) &#123; String string = fileList[i]; File file = new File(dirFile.getPath(), string); String name = file.getName(); //如果是一个目录，搜索深度depth++，输出目录名后，进行递归 if (file.isDirectory()) &#123; //递归 transferFile(file.getCanonicalPath(), currentDepth); &#125; else &#123; if (name.contains(\".java\") || name.contains(\".properties\") || name.contains(\".xml\")) &#123; readAndWrite(file); System.out.println(name + \" has converted to utf8 \"); &#125; &#125; &#125; &#125; private static boolean isValidFile(File dirFile) throws IOException &#123; if (dirFile.exists()) &#123; System.out.println(\"file exist\"); return true; &#125; if (dirFile.isDirectory()) &#123; if (dirFile.isFile()) &#123; System.out.println(dirFile.getCanonicalFile()); &#125; return true; &#125; return false; &#125; private static void readAndWrite(File file) throws Exception &#123; String content = FileUtils.readFileByEncode(file.getPath(), \"GBK\"); FileUtils.writeByBufferedReader(file.getPath(), new String(content.getBytes(\"UTF-8\"), \"UTF-8\")); &#125; public static void main(String[] args) throws Exception &#123; //程序入口，制定src的path String path = \"/Users/mac/Downloads/unit06_jdbc/src\"; transferFile(path, 1); &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class FileUtils &#123; public static void writeByBufferedReader(String path, String content) &#123; try &#123; File file = new File(path); file.delete(); if (!file.exists()) &#123; file.createNewFile(); &#125; FileWriter fw = new FileWriter(file, false); BufferedWriter bw = new BufferedWriter(fw); bw.write(content); bw.flush(); bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static String readFileByEncode(String path, String chatSet) throws Exception &#123; InputStream input = new FileInputStream(path); InputStreamReader in = new InputStreamReader(input, chatSet); BufferedReader reader = new BufferedReader(in); StringBuffer sb = new StringBuffer(); String line = reader.readLine(); while (line != null) &#123; sb.append(line); sb.append(\"\\r\\n\"); line = reader.readLine(); &#125; return sb.toString(); &#125;&#125; 总结遇到类似的问题，都可以试着用代码来进行实现，给自己的编码带来一些新的乐趣，也增加自己的信心。 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhangfuxin.cn/categories/编程语言/"}],"tags":[{"name":"java","slug":"java","permalink":"http://zhangfuxin.cn/tags/java/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhangfuxin.cn/categories/编程语言/"}]},{"title":"阿拉伯数字转汉字写法","slug":"num2Chinese","date":"2017-07-29T14:25:27.000Z","updated":"2019-08-21T15:13:24.135Z","comments":true,"path":"num2Chinese.html","link":"","permalink":"http://zhangfuxin.cn/num2Chinese.html","excerpt":"** 阿拉伯数字转汉字写法：** &lt;Excerpt in index | 首页摘要&gt;找工作时看到“某团”的题目，把一个int的数字转为汉字的读法，比如123，转成一百二十三，限时20分钟。如果二十分钟做不出来，简历就不要投了。说实话，20分钟能调通的人真的不多，感觉某团还是装逼成分太多！","text":"** 阿拉伯数字转汉字写法：** &lt;Excerpt in index | 首页摘要&gt;找工作时看到“某团”的题目，把一个int的数字转为汉字的读法，比如123，转成一百二十三，限时20分钟。如果二十分钟做不出来，简历就不要投了。说实话，20分钟能调通的人真的不多，感觉某团还是装逼成分太多！ &lt;The rest of contents | 余下全文&gt; 题目要求用java实现，把int的数字转为汉字读音，比如123，转成一百二十三，10020转为一万零二十 思路分析中文计数的特点，以万为小节，万以内的都是以“十百千”为权位单独计数，比如一千百，一千千都是非法的。而“十百千”这样的权位可以与“万”，“亿”进行搭配，二十亿，五千万等等。 中文数字的零中文的零的使用总结起来有三个规则， 以10000为小节，结尾是0，不使用零，比如1020 以10000为小节，小节内两个非0数字之间需要零 小节的千位是0，若小节前无其他数字，不用零，否者用零 完整代码（参考算法的乐趣第四章）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class NumberTransfer &#123; public final String[] chnNumChar = new String[]&#123;\"零\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\"&#125;; public final String[] chnUnitSection = new String[]&#123;\"\", \"万\", \"亿\", \"万亿\"&#125;; public final String[] chnUnitChar = new String[]&#123;\"\", \"十\", \"百\", \"千\"&#125;; @Test public void testNumberToChinese() &#123; int[] nums = new int[]&#123;304, 4006, 4000, 10003, 10030, 21010011, 101101101&#125;; for (int i = 0; i &lt; nums.length; i++) &#123; System.out.println(numberToChinese(nums[i])); &#125; &#125; public String numberToChinese(int num) &#123; String strIns; String chnStr = \"\"; int unitPos = 0; boolean needZero = false; if (num == 0) return \"零\"; while (num &gt; 0) &#123; strIns = \"\"; int section = num % 10000; if (needZero) &#123; chnStr = chnNumChar[0] + chnStr; &#125; // 添加节权（万，亿） strIns += (section != 0) ? chnUnitSection[unitPos] : chnUnitSection[0]; chnStr = strIns + chnStr; // 以万为单位，求万以内的权位 chnStr = sectionToChinese(section, chnStr); needZero = (section &lt; 1000) &amp;&amp; (section &gt; 0); num = num / 10000; unitPos++; &#125; return chnStr; &#125; private String sectionToChinese(int section, String chnStr) &#123; String strIns; int unitPos = 0; boolean zero = true; while (section &gt; 0) &#123; int v = section % 10; if (v == 0) &#123; if (section == 0 || !zero) &#123; zero = true;// zero确保不会出现多个零 chnStr = chnNumChar[v] + chnStr; &#125; &#125; else &#123; zero = false; strIns = chnNumChar[v]; // 此位置对应等中文数字 strIns += chnUnitChar[unitPos];// 此位置对应的权位 chnStr = strIns + chnStr; &#125; unitPos++; section = section / 10; &#125; return chnStr; &#125;&#125; 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"java面试大全自制版","slug":"java-interview","date":"2017-07-24T13:07:00.000Z","updated":"2019-08-21T15:13:24.129Z","comments":true,"path":"java-interview.html","link":"","permalink":"http://zhangfuxin.cn/java-interview.html","excerpt":"** java面试大全自制版：** &lt;Excerpt in index | 首页摘要&gt;java语言知识点多而杂，面试时很多人找不到重点。这份java面试大全，有部分网络上资源，大多数是从好的文章和书籍里总结出来的知识点。","text":"** java面试大全自制版：** &lt;Excerpt in index | 首页摘要&gt;java语言知识点多而杂，面试时很多人找不到重点。这份java面试大全，有部分网络上资源，大多数是从好的文章和书籍里总结出来的知识点。 &lt;The rest of contents | 余下全文&gt; 本书的目的每个java程序员在面试前都不知该准备什么？或者是随便看几个文章就去面试，这样的结果很容易失败！希望本书能给java程序员一个好的指引，让java程序员没有难找的工作！ 目录gitbook地址 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://zhangfuxin.cn/categories/学习笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"http://zhangfuxin.cn/tags/java/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://zhangfuxin.cn/categories/学习笔记/"}]},{"title":"kobo aura one导出笔记高级配置","slug":"kobo-config","date":"2017-06-23T02:22:57.000Z","updated":"2019-08-21T15:13:24.129Z","comments":true,"path":"kobo-config.html","link":"","permalink":"http://zhangfuxin.cn/kobo-config.html","excerpt":"** kobo aura one导出笔记高级配置：** &lt;Excerpt in index | 首页摘要&gt;kobo电子书折腾记，导出笔记，从激活到设置，打补丁实现自定义配置，还是自己折腾起来有意思啊。","text":"** kobo aura one导出笔记高级配置：** &lt;Excerpt in index | 首页摘要&gt;kobo电子书折腾记，导出笔记，从激活到设置，打补丁实现自定义配置，还是自己折腾起来有意思啊。 &lt;The rest of contents | 余下全文&gt; 建议买电子书是为了阅读和学习，不是天天折腾电子书，一天刷一次机，如果只是看书，做笔记，学个英文什么的原生系统是最好的。如果看pdf为主，不建议买这电子书，看pdf首选电脑，平板，sony dsp系列，用普通的电子书阅读器，体验太差。 kobo原生系统的功能（推荐原生系统，打上补丁） 格式支持epub，mobi，cbz漫画，txt，kobo epub格式 高亮，笔记，导出笔记（需要配置一下） 字典（英文，中文，法文等多国字典，可以自己修改） 阅读pocket文章（可以把网页保存到pocket，实用pocket同步到阅读器） 自动亮度（最大的优点） koreader的功能 格式支持epub，mobi，cbz漫画，txt，kobo epub格式 扫描版pdf支持重拍，切边（最大特色） 笔记导出到印象笔记 字典（强大的字典扩展） 激活说明：wifi激活需要翻墙，可以实用笔记连接vpn，然后共享wifi给kobo wifi激活, kobo setup desktop激活，去kobo官网下载软件，然后电脑需要翻墙，电子书连接上电脑，用软件登录激活。这个软件很不好用，bug也多，建议使用wifi激活。 更新固件，打补丁kobo的更新固件，更新补丁都是一个模式，把固件或者补丁放到.kobo文件夹，弹出设备就会自动重启 字体电脑连接kobo，在根目录建立一个fonts文件夹，把需要的字体放进去即可 词典下载网上改好的字典，直接放到.kobo文件夹下的dict目录下，然后重启就可以了 自定义配置 刷新页数（打补丁） 上下页宽（打补丁） 全屏模式（修改配置文件） 字体高级设置（修改配置文件） 导出笔记和高亮（修改配置文件） kobo高级配置文件详解用电脑连接kobo电子书，打开Kobo找到eReader.conf文件，最好用notepad++修改，或者其他文本编辑器。 12345678910111213141516171819202122232425262728[FeatureSettings]#导出笔记ExportHighlightsEnabled=true#显示全书的页码，而不是章节的页码FullBookPageNumbers=true#用在线等维基百科代替词典查询OnlineWikipedia=true#全屏阅读FullScreenReading=true#图片缩放ImageZoom=true#浏览器全屏FullScreenBrowser=true#关机键截图，但是关机键就无法关机了，不要设置这个鸡肋的功能Screenshots=true[Reading]#翻页刷新的页数，20页全刷一次numPartialUpdatePageTurns=20#左边距readingLeftMargin=0#右边距readingRightMargin=0#行高readingLineHeight=1.4[PowerOptions]#自动关机时间AutoOffMinutes=60 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/categories/others/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/tags/开发工具/"}],"keywords":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/categories/others/"}]},{"title":"Illegal mix of collations","slug":"mysql-collation","date":"2017-06-12T03:00:14.000Z","updated":"2019-08-21T15:13:24.132Z","comments":true,"path":"mysql-collation.html","link":"","permalink":"http://zhangfuxin.cn/mysql-collation.html","excerpt":"** mysql排序字符集问题：** &lt;Excerpt in index | 首页摘要&gt;mysql表的每个字段都可以设置单独的排序字符集和文本字符集，如果你创建表的时候不注意，很可能会遇到Illegal mix of collations这个问题。","text":"** mysql排序字符集问题：** &lt;Excerpt in index | 首页摘要&gt;mysql表的每个字段都可以设置单独的排序字符集和文本字符集，如果你创建表的时候不注意，很可能会遇到Illegal mix of collations这个问题。 &lt;The rest of contents | 余下全文&gt; 问题描述用mysql进行两个表的联合查询的时候，出现下面的错误。 1Illegal mix of collations (utf8_unicode_ci,IMPLICIT) and (utf8_general_ci,IMPLICIT) for operation &apos;=&apos; 排查过程 通过google搜索找到原因，这个错误是mysql的排序字符集不一致导致的。 把联合查询的表使用navicat查看字段的设置，发现了有一个关联字段排序字符集的问题，如图： 这两个表中openid的排序规则不一致，导致出现问题。 解决方法将user表中的字符集和排序规则设置为默认，保持一致即可。 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://zhangfuxin.cn/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}]},{"title":"mongodb从入门到精通","slug":"mongodb-study","date":"2017-05-26T15:21:23.000Z","updated":"2019-08-21T15:13:24.131Z","comments":true,"path":"mongodb-study.html","link":"","permalink":"http://zhangfuxin.cn/mongodb-study.html","excerpt":"** mongodb从入门到精通** &lt;Excerpt in index | 首页摘要&gt; mongodb日常使用的一些知识，增删改查，索引，分片。","text":"** mongodb从入门到精通** &lt;Excerpt in index | 首页摘要&gt; mongodb日常使用的一些知识，增删改查，索引，分片。 &lt;The rest of contents | 余下全文&gt; mongodb学习1.mongodb特性1）mongo是一个面向文档的数据库，它集合了nosql和sql数据库两方面的特性。 2）所有实体都是在首次使用时创建。 3）没有严格的事务特性，但是它保证任何一次数据变更都是原子性的。 4）也没有固定的数据模型 5）mongo以javascript作为命令行执行引擎，所以利用shell进行复杂的计算和查询时会相当的慢。 6）mongo本身支持集群和数据分片 7）mongo是c++实现的，支持windows mac linux等主流操作系统 8）性能优越，速度快2.mongo常用操作增删操作123456db.user.insert(&#123;name:'aaaa',age:30&#125;);db.user.save(&#123;name:'aaaa',age:30&#125;);db.collection.insertOne(&#123;&#125;);//(3.2新特性)db.collection.deleteOne(&#123;&#125;,&#123;&#125;);//(3.2新特性)db.collection.remove(&#123;name:'aaa'&#125;);db.collection.remove();//(删除全部) 更新操作12345db.users.update(&#123;\"name\": \"joe\"&#125;, joe );//upsert模式db.users.update(&#123;\"name\": \"joe\"&#125;, joe, true );//MULTI模式db.users.update(&#123;\"name\": \"joe\"&#125;, joe, true ，true); update是对文档替换，而不是局部修改默认情况update更新匹配的第一条文档，multi模式更新所有匹配的 查询操作普通查询 123db.user.find();db.user.find(&#123;name:'aaa'&#125;);db.user.findOne(&#123;name:'aaa'&#125;); 模糊查询 12db.UserInfo.find(&#123;userName :'/A/'&#125;) //（名称%A%）db.UserInfo.find(&#123;userName :'/^A/'&#125;) //(名称A%) 操作符 $lt, $lte,$gt, $gte(&lt;, &lt;=, &gt;, &gt;= ) $all 数组中的元素是否完全匹配 db.things.find( { a: { $all: [ 2, 3 ] } } ); $exists 可选：true，false db.things.find( { a : { $exists : true } } ); $mod 取模：a % 10 == 1 db.things.find( { a : { $mod : [ 10 , 1 ] } } ); $ne 取反：即not equals db.things.find( { x : { $ne : 3 } } ); $in 类似于SQL的IN操作 db.things.find({j:{$in: [2,4,6]}}); $nin $in的反操作，即SQL的 NOT IN db.things.find({j:{$nin: [2,4,6]}}); $nor $or的反操作，即不匹配(a或b) db.things.find( { name : “bob”, $nor : [ { a : 1 },{ b : 2 }]}) $or Or子句，注意$or不能嵌套使用 db.things.find( { name : “bob” , $or : [ { a : 1 },{ b : 2 }]}) $size 匹配数组长度 db.things.find( { a : { $size: 1 } } ); $type 匹配子键的数据类型，详情请看 db.things.find( { a : { $type : 2 } } ); 数组查询$size 用来匹配数组长度（即最大下标）// 返回comments包含5个元素的文档db.posts.find({}, {comments:{‘$size’: 5}});// 使用冗余字段来实现db.posts.find({}, {‘commentCount’: { ‘$gt’: 5 }});$slice 操作符类似于子键筛选，只不过它筛选的是数组中的项// 仅返回数组中的前5项db.posts.find({}, {comments:{‘$slice’: 5}});// 仅返回数组中的最后5项db.posts.find({}, {comments:{‘$slice’: -5}});// 跳过数组中的前20项，返回接下来的10项db.posts.find({}, {comments:{‘$slice’: [20, 10]}});// 跳过数组中的最后20项，返回接下来的10项db.posts.find({}, {comments:{‘$slice’: [-20, 10]}});MongoDB 允许在查询中指定数组的下标，以实现更加精确的匹配// 返回comments中第1项的by子键为Abe的所有文档db.posts.find( { “comments.0.by” : “Abe” } ); 3.索引的使用创建索引12345678db.things.ensureIndex(&#123;'j': 1&#125;);//创建子文档 索引db.things.ensureIndex(&#123;'user.Name' : - 1&#125;);//创建 复合 索引db.things.ensureIndex(&#123;'j' : 1 , // 升序'x' : - 1 // 降序&#125;); 如果 您的 find 操作只用到了一个键，那么索引方向是无关紧要的 当创建复合索引的时候，一定要谨慎斟酌每个键的排序方向 修改索引修改索引，只需要重新 运行索引 命令即可如果索引已经存在则会 重建， 不存在的索引会被 添加 1234567891011db.things.ensureIndex (&#123; //原来的索引会 重建 'user.Name ' : - 1 , //新增一个升序 索引 'user.Name ' : 1 , //为 Age 新建降序 索引 'user.Age ' : - 1 //打开后台执行&#125;,&#123; 'background' : true&#125;);//重建索引db.things.reIndex(); 删除索引1234567891011121314//删除集合中的所有 索引db.things.dropIndexes (); //删除指定键的索引 db.things.dropIndex (&#123; x : 1 , y : - 1&#125;); //使用 command 删除指定键的 索引db.runCommand (&#123; dropIndexes : 'foo ' , index:&#123; y : 1 &#125;&#125;); //使用 command 删除所有 索引db.runCommand (&#123;dropIndexes : 'foo ',index: '*'&#125;) 如果是删除集合中所有的文档（remove）则不会影响索引，当有新文档插入时，索引就会重建。 唯一索引创建唯一索引，同时这也是一个符合唯一索引 12345678910db.things.ensureIndex (&#123; 'firstName ' : 1 , 'lastName ' : 1&#125;, &#123;//指定为唯一索引'unique': true ,//删除重复 记录'dropDups': true&#125;); 强制使用索引12345678910111213//强制使用索引 a 和 bdb.collection.find(&#123; 'a' : 4 , 'b' : 5 , 'c' : 6&#125;).hint(&#123; 'a' : 1 , 'b' : 1&#125;);//强制不使用任何 索引db.collection.find().hint(&#123; '$natural' : 1&#125;); 索引总结: 索引可以加速查询； 单个索引无需在意其索引方向； 多键索引需要慎重考虑每个索引的方向； 做海量数据更新时应当先卸载所有索引，待数据更新完成后再重建索引； 不要试图为每个键都创建索引，应考虑实际需要，并不是索引越多越好； 唯一索引可以用来消除重复记录； 地理空间索引是没有单位的，其内部实现是基本的勾股定理算法 4.mongo数据库管理安全与认证 默认为无认证，启动用登录 shell ； 添加账号； 关闭 shell .关闭 MongoDB ； 为 MongoDB 增加 — auth 参数； 重 启 MongoDB ； 登录 shell ，此时就需要认证了 冷备份 关闭MongoDB引擎 拷贝数据库文件夹及文件 恢复时反向操作即可 优点：可以完全保证数据完整性； 缺点：需要数据库引擎离线 热备份 保持MongoDB为运行状态 使用mongodump备份数据 使用mongorestore恢复数据 优点：数据库引擎无须离线 缺点：不能保证数据完整性，操作时会降低MongoDB性能 主从复制备份 创建主从复制机制 配置完成后数据会自动同步 恢复途径很多 优点：可以保持MongoDB处于联机状态，不影响性能 缺点：在数据写入密集的情况下可能无法保证数据完整性 修复db.repairDatabase(); 修复数据库还可以起到压缩数据的作用； 修复数据库的操作相当耗时，万不得已请不要使用； 建议经常做数据备份；5.mongo复制(集群) 主从复制选项 说明 –only 作用是限定仅复制指定的某个数据库–slavedelay 为复制设置操作延迟，单位为秒–fastsync 以主节点的数据快照为基础启动从节点。–autoresync 当主从节点数据不一致时，是否自动重新同步–oplogSize 设定主节点中的oplog的容量，单位是MB 副本集与普通主从复制集群相比，具有自动检测机制需要使用—replSet 选项指定副本同伴任何时候，副本集当中最多只允许有1个活跃节点 读写分离将密集的读取操作分流到从节点上，降低主节点的负载默认情况下，从节点是不允许处理客户端请求的，需要使用—slaveOkay打开不适用于实时性要求非常高的应用 工作原理—— OPLOGoplog保存在local数据库中，oplog就在其中的oplog.$main集合内保存。该集合的每个文档都记录了主节点上执行的一个操作，其键定义如下： ts：操作时间戳，占用4字节 op：操作类型，占用1字节 ns：操作对象的命名空间（或理解为集合全名） o：进一步指定所执行的操作，例如插入 工作原理—— 同步 从节点首次启动时，做完整同步 主节点数据发生变化时，做增量同步 从节点与主节点数据严重不一致时，做完整同步 复制管理—— 诊断db.printReplicationInfo()在主节点上使用 返回信息是oplog的大小以及各种操作的耗时. 空间占用等数据在从节点上使用db.printSlaveReplicationInfo() 返回信息是从节点的数据源列表. 同步延迟时间等 复制管理—— 变更OPLOG 容量在主节点上使用 设定—oplogSize参数 重启MongoDB 复制管理—— 复制认证主从节点皆须配置 存储在local.system.users 优先尝试repl用户 主从节点的用户配置必须保持一致 6.MONGODB分片分片与自动分片分片是指将数据拆分，分散到不同的实例上进行负载分流的做法。我们常说的“分表”、“分库”、“分区”等概念都属于分片的实际体现。传统分片做法是手工分表、分库。自动分片技术是根据指定的“片键”自动拆分数据并维护数据请求路由的过程。 递增片键–连续 不均匀 写入集中 分流较差 随机片键–不连续 均匀 写入分散 分流较好 三个组成部分 片,保存子集数据的容器 mongos,MongoDB的路由器进程 配置服务器,分·片集群的配置信息创建分片 –启动配置服务器,可以创建一个或多个 –添加片,每个片都应该是副本集 –物理服务器,性能、安全和稳定性管理分片12345678910//查询分片db.shards.find();//数据库db.databases.find();//块db.chunks.find();//分片状态db.printShardingStatus();//删除片db.runCommand(&#123; removeshard : 'ip:port' &#125;);","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://zhangfuxin.cn/tags/mongodb/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}]},{"title":"hexo自用黑色主题","slug":"hexo-theme","date":"2017-05-23T03:32:59.000Z","updated":"2019-08-21T15:13:24.127Z","comments":true,"path":"hexo-theme.html","link":"","permalink":"http://zhangfuxin.cn/hexo-theme.html","excerpt":"** hexo和coding打造静态博客 ：** &lt;Excerpt in index | 首页摘要&gt;使用hexo一年有余，对所有主题都感觉有所缺陷，便修改了一个自用黑色主题，本主题以黑色和蓝色为主，色彩鲜明，主题明确。","text":"** hexo和coding打造静态博客 ：** &lt;Excerpt in index | 首页摘要&gt;使用hexo一年有余，对所有主题都感觉有所缺陷，便修改了一个自用黑色主题，本主题以黑色和蓝色为主，色彩鲜明，主题明确。 &lt;The rest of contents | 余下全文&gt; 主题图片 black-blue主题来源本主题修改自spfk主题，但之前spfk主题有很多问题，本主题改进如下： 压缩js，css提高性能 代码段样式显示更完美 增加本地搜索 设置更合适的字体大小 颜色以黑色和蓝色为主，色彩鲜明 seo适当优化 删除多说，有言，增加畅言评论 删除stylus，全部改用css方便修改 主题地址black-blue 注意：大家使用主题的时候，把主题配置文件_config.yml以下几项必须修改，项目里实用的是我博客的正式代码，请大家修改成自己的！ 12345678910google_analytics: xxxbaidu_analytics: xxxxxxxdisqus: on: false shortname: xxxx# 畅言评论changyan: on: true appid: xxxx conf: xxxxx black-blue主题配置切换主题复制主题到themes目录下cd themes &amp;&amp; git clone https://github.com/maochunguang/black-blue，修改_config.yml theme: black-blue 安装常用插件，建议全部安装123456789## rss插件npm install hexo-generator-feed --save## 站点sitemap生成插件npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save## 百度url提交npm install hexo-baidu-url-submit --save## 本地搜索插件集成npm install hexo-generator-search --save 博客全局配置，修改根目录下_config.yml插件配置 1234Plugins:- hexo-generator-feed- hexo-generator-sitemap- hexo-generator-baidu-sitemap rss设置 1234feed: type: atom path: atom.xml limit: 20 本地搜索配置 123search: path: search.json field: post 站点地图，seo搜索引擎需要 1234sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 主题配置菜单配置 123456789## 添加单独的页面:hexo new page about，about是页面的路径，也是名称## Tags Cloud Page: `hexo new page tags`menu: # 主页: /archives/ 所有文章: /archives/ 玩转开发工具: /categories/开发工具/ 玩转数码: /categories/digital 认知提升: /categories/cognition 关于我: /about/ 评论配置 123456789# 是否开启畅言评论，changyan: on: true appid: xxxx conf: xxxxxxxxxxxx# 是否开启disqus，disqus: on: false shortname: mmmmmm 其他配置，详细的配置请下载主题，都有注释1234567# 数学公式支持mathjax: false# Socail Share | 是否开启分享baidushare: true# 谷歌分析，百度分析，seo分析很有用google_analytics: xxxxxxbaidu_analytics: xxcxcxcsdsf 自定义配置（对前端技术有了解即可）显示更多和折叠文章你的md文件格式需要按下面的来： 12345678910title: 突破算法第11天-红黑树date: 2017-10-30 22:35:37tags: 算法categories: algorithm---** &#123;&#123; title &#125;&#125;：** &lt;Excerpt in index | 首页摘要&gt;红黑树&lt;!-- more --&gt;&lt;The rest of contents | 余下全文&gt;正文…… 头像配置在themes/black-blue/source/img/avatar.png,替换此头像即可实现自定义头像 背景图片配置在themes/black-blue/source/background/,替换为自己喜欢的图片，图片名称不能改 添加评论插件比如把畅言替换为有言 先修改themes/black-blue/_config.yml文件 123changyan: on: true uid: xxxxxxx 修改themes/black-blue/layout/_partial/comments/changyan.ejs 12345&lt;section class=\"changyan\" id=\"comments\"&gt;&lt;div id=\"uyan_frame\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"http://v2.uyan.cc/code/uyan.js?uid=&lt;%= uid%&gt;\"&gt;&lt;/script&gt;&lt;/section&gt; 修改themes/black-blue/layout/_partial/article.ejs 123&lt;%- partial('comments/changyan', &#123; uid: theme.changyan.uid&#125;) %&gt; 重新生成页面hexo g","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://zhangfuxin.cn/tags/hexo/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}]},{"title":"数码产品选购","slug":"digital-info","date":"2017-05-18T02:35:22.000Z","updated":"2019-08-21T15:13:24.121Z","comments":true,"path":"digital-info.html","link":"","permalink":"http://zhangfuxin.cn/digital-info.html","excerpt":"** 数码产品选购：** &lt;Excerpt in index | 首页摘要&gt;作为一个数码产品控，一出新的的电子产品，我都欣喜若狂。看参数，看评价，感觉合适，就会买。","text":"** 数码产品选购：** &lt;Excerpt in index | 首页摘要&gt;作为一个数码产品控，一出新的的电子产品，我都欣喜若狂。看参数，看评价，感觉合适，就会买。 &lt;The rest of contents | 余下全文&gt; 我喜欢的电子产品 电脑（笔记本，台式机，游戏主机，工作站） 手机（苹果，安卓，其它智能手机） 平板（安卓平板，ios平板） 电子书阅读器 电子手表 选购的原则 产品生态，买电子产品虽然不是随大流，但是用户群体一定程度决定了生态。用的人多，相应的资源会比较丰富，遇到问题很快找到解决方案。 产品价格，性价比在中国，乃至全世界都是很具有吸引力的。物美价廉的都不买的要么是脑残，要么是钱多没地方花。 产品硬件参数，买电子产品不看参数，肯定是买不到物美价廉的产品。 产品外观，现在是看脸的时代，新时代的数码产品对外观要求更高，更时尚。 功能，买电子产品，首要的就是功能，如果功能都不齐全，再漂亮，再便宜都没用。 买电子产品的目的，没有任何需求就是瞎买。 电子产品的使用我见过很多人买电子产品，比如买电子书阅读器，买一个kobo电子书折腾来折腾去，今天刷这个系统，明天改那个设置，书还没读几本，系统刷了几十次，天天刷固件。这真的是得不偿失，捡了芝麻丢了西瓜。第一，买电子产品是为了用的，买回来之后配置好之后，就不要来回折腾系统和配置了，把时间放到核心功能上。第二，买电子产品不要攀比，就跟买苹果手机一样，如果只是为了装B买，真没必要，结果自己还用不习惯。第三，了解自己的需求，需要什么买什么， 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"digital","slug":"digital","permalink":"http://zhangfuxin.cn/categories/digital/"}],"tags":[{"name":"数码产品","slug":"数码产品","permalink":"http://zhangfuxin.cn/tags/数码产品/"}],"keywords":[{"name":"digital","slug":"digital","permalink":"http://zhangfuxin.cn/categories/digital/"}]},{"title":"如何写一篇好博客？","slug":"bestblog","date":"2017-05-15T15:04:48.000Z","updated":"2019-08-21T15:13:24.119Z","comments":true,"path":"bestblog.html","link":"","permalink":"http://zhangfuxin.cn/bestblog.html","excerpt":"** 提高自己博客的质量：** &lt;Excerpt in index | 首页摘要&gt;写博客陆陆续续也有一年了，但是一直没有多少访问量，仔细看了很多大神的博客，总结了几点，分享一下。","text":"** 提高自己博客的质量：** &lt;Excerpt in index | 首页摘要&gt;写博客陆陆续续也有一年了，但是一直没有多少访问量，仔细看了很多大神的博客，总结了几点，分享一下。 &lt;The rest of contents | 余下全文&gt; 好博客，好文章是什么样的？ 文章名称鲜明，一看名称就知道关于什么的内容 整体结构清晰，把事件或者原理的始末按照‘什么样（what？）’，‘为什么（why）’，‘怎么做（how）’说明 简明扼要。太啰嗦，没人看。 难易适中，太高深也没人看 图文搭配，有句话说的好，一图胜千文，好的图片胜过千言万语 怎么写出好博客？ 定主题和文章名称。如果想写一个关于redis后台启动的文章，名称要准确，就叫redis后台启动，不要起啰嗦的名字，比如redis如何后台启动 准备资料阶段，熟悉redis配置相关资料，做好功课 定文章的结构和提纲。还拿这个redis后台启动为例，你得说明什么是后台启动？为什么要后台启动？如何做到后台启动？ 语言表单，简单直白，不用凑字数 深入主题，比如挖掘更多redis的配置，把参数简要说明 找一个好图片，如果找不到，自己制作一个最契合自己主题的图片 把文章发给好友阅读，提出宝贵的意见 改进博客 坚持写博客 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"个人随笔","slug":"个人随笔","permalink":"http://zhangfuxin.cn/categories/个人随笔/"}],"tags":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/tags/others/"}],"keywords":[{"name":"个人随笔","slug":"个人随笔","permalink":"http://zhangfuxin.cn/categories/个人随笔/"}]},{"title":"redis后台启动详细配置","slug":"redis-config","date":"2017-05-15T14:58:07.000Z","updated":"2019-08-21T15:13:24.135Z","comments":true,"path":"redis-config.html","link":"","permalink":"http://zhangfuxin.cn/redis-config.html","excerpt":"** redis后台启动详细配置：** &lt;Excerpt in index | 首页摘要&gt; redis启动的时候有多种模式，后台启动，集群启动等等。","text":"** redis后台启动详细配置：** &lt;Excerpt in index | 首页摘要&gt; redis启动的时候有多种模式，后台启动，集群启动等等。 &lt;The rest of contents | 余下全文&gt; 说明在开发中一般都是在命令行中直接运行redis-server,但是这样命令行关闭，服务就停止了。如果要在后台运行redis服务，需要制定配置文件。这里以ubuntu14为例子 准备配置文件查看‘/etc/redis/redis.conf’,没有可以创建一个，或者下载一个，配置文件位置没有要求 修改配置文件把daemonize设置为yes，然后redis-server /etc/redis/redis.conf启动服务， 查看服务ps -ef|grep redis-server查看是否有redis进程存在 更多配置，在conf文件有说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 是否以后台daemon方式运行，默认是 no，一般我们会改为 yesdaemonize nopidfile /var/run/redis.pid# 只允许本机访问bind 127.0.0.1# 端口设置port 6379tcp-backlog 511timeout 0tcp-keepalive 0loglevel notice# 日志文件logfile &quot;&quot;# 开启数据库的数量，Redis 是有数据库概念的，默认是 16 个，数字从 0 ~ 15databases 16save 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yesdbfilename dump.rdbdir ./slave-serve-stale-data yesslave-read-only yesrepl-diskless-sync norepl-diskless-sync-delay 5repl-disable-tcp-nodelay no# 密码设置，需要设置密码打开requirepass 123455slave-priority 100appendonly noappendfilename &quot;appendonly.aof&quot;appendfsync everysecno-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yeslua-time-limit 5000slowlog-log-slower-than 10000slowlog-max-len 128latency-monitor-threshold 0notify-keyspace-events &quot;&quot;hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-entries 512list-max-ziplist-value 64set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60hz 10aof-rewrite-incremental-fsync yes 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://zhangfuxin.cn/tags/redis/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}]},{"title":"用koa2.x写下载漫画的爬虫","slug":"spider-koa2","date":"2017-05-13T23:15:38.000Z","updated":"2019-08-21T15:13:24.138Z","comments":true,"path":"spider-koa2.html","link":"","permalink":"http://zhangfuxin.cn/spider-koa2.html","excerpt":"** 用koa2.x写下载漫画的爬虫：** &lt;Excerpt in index | 首页摘要&gt;使用koa2.x的async ，await解决异步问题，写一个下载漫画的爬虫，代码里有惊喜和福利哦！","text":"** 用koa2.x写下载漫画的爬虫：** &lt;Excerpt in index | 首页摘要&gt;使用koa2.x的async ，await解决异步问题，写一个下载漫画的爬虫，代码里有惊喜和福利哦！ &lt;The rest of contents | 余下全文&gt; 项目搭建 安装nodejs&gt;7.6,安装koa-generator 直接koa2 spider,生成项目 安装request,request-promise,cheerio,mkdirp npm install安装依赖 思路图片或者漫画爬虫的思路很简单，首先观察url的规律，把url按规律加入到下载任务，其实就是请求获得html内容，然后对html进行解析，找到下载的图片url（一般都是img标签的src属性值），把url放到数组保存，使用async await控制所有的任务，直到把所有的图片下载完。 难点但是nodejs本身上异步的，如果你直接在for循环里去下载，肯定是不行的，必须控制好异步的执行上关键。爬虫简单，处理好异步难。这里我使用的es7中async，await配合promise解决异步问题，还可以使用async模块，eventproxy，等等异步控制模块来解决。 核心代码,spider.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const fs = require('fs');const request = require(\"request-promise\");const cheerio = require(\"cheerio\");const mkdirp = require('mkdirp');const config = require('../config');exports.download = async function(ctx, next) &#123; const dir = 'images'; // 图片链接地址 let links = []; // 创建目录 mkdirp(dir); var urls = []; let tasks = []; let downloadTask = []; let url = config.url; for (var i = 1; i &lt;= config.size; i++) &#123; let link = url + '_' + i + '.html'; if (i == 1) &#123; link = url + '.html'; &#125; tasks.push(getResLink(i, link)) &#125; links = await Promise.all(tasks) console.log('links==========', links.length); for (var i = 0; i &lt; links.length; i++) &#123; let item = links[i]; let index = item.split('___')[0]; let src = item.split('___')[1]; downloadTask.push(downloadImg(src, dir, index + links[i].substr(-4, 4))); &#125; await Promise.all(downloadTask);&#125;async function downloadImg(url, dir, filename) &#123; console.log('download begin---', url); request.get(url).pipe(fs.createWriteStream(dir + \"/\" + filename)).on('close', function() &#123; console.log('download success', url); &#125;);&#125;async function getResLink(index, url) &#123; const body = await request(url); let urls = []; var $ = cheerio.load(body); $(config.rule).each(function() &#123; var src = $(this).attr('src'); urls.push(src); &#125;); return index + '___' + urls[0];&#125; 基础配置由于爬虫的复杂性基于不同的网站，不同的任务很不一样，这里只是把几个常用的变量抽取到了config.js。 1234567module.exports = &#123; //初始url url: 'http://www.xieet.com/meinv/230', size: 10, // 选中图片img标签的选择器 rule: '.imgbox a img'&#125;; 运行代码 下载我上传的代码koa-spider npm install,npm start即可运行 总结其实无论是写爬虫还是些其他程序，使用nodejs很大一部分都是要处理异步，要学好nodejs必须学好异步处理。 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://zhangfuxin.cn/categories/学习笔记/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://zhangfuxin.cn/tags/nodejs/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://zhangfuxin.cn/categories/学习笔记/"}]},{"title":"微信公众号开发","slug":"wechat-dev","date":"2017-04-28T04:55:33.000Z","updated":"2019-08-21T15:13:24.147Z","comments":true,"path":"wechat-dev.html","link":"","permalink":"http://zhangfuxin.cn/wechat-dev.html","excerpt":"** 微信公众号开发：** &lt;Excerpt in index | 首页摘要&gt;微信公众号开发的一些注意事项","text":"** 微信公众号开发：** &lt;Excerpt in index | 首页摘要&gt;微信公众号开发的一些注意事项 &lt;The rest of contents | 余下全文&gt; 开发环境搭建 微信公众号开发者配置，url，token， 本地调试，使用内网穿透工具，花生壳，或者netapp，买一个可以自定义域名的，内网映射到制定端口， 项目搭建，express或koa搭建项目，npm有微信的现成包，直接配置 回复 回复和发消息并没有什么特别注意的地方，这里不多说 菜单 微信菜单有自定义菜单，有个性化菜单，但是个性化菜单优先级高于个性化菜单 个性化菜单可以根据用户的tag，sex，group等属性进行区分菜单 注意，我在使用时发现个性化菜单经常会失效，不起作用，偶尔会起作用，如果线上打算使用个性化菜单，请慎重并仔细测试 授权授权有网页授权，js sdk授权，网页授权也有两种，一个上静默授权，一个是点击授权，贴一下js sdk调用前认证的代码，要使用sha1加密 123456789101112131415async getSignConfig(originUrl) &#123; let data = &#123;&#125; const sha1 = crypto.createHash('sha1') const appId = this.app.config.weixin.appID const jsapi_ticket = await this.ctx.service.token.getJSApiTicket() const noncestr = this.app.config.jsapi.noncestr const url = this.app.config.domain + originUrl const timestamp = parseInt(new Date().getTime() / 1000) // sha1加密 const str = `jsapi_ticket=$&#123;jsapi_ticket&#125;&amp;noncestr=$&#123;noncestr&#125;&amp;timestamp=$&#123;timestamp&#125;&amp;url=$&#123;url&#125;` sha1.update(str) const signature = sha1.digest('hex') data = &#123; jsapi_ticket, noncestr, timestamp, url, signature, appId &#125; return data &#125; 调用js sdk页面上代码 12345678910111213wx.config(&#123; debug: false, // 开启调试模式, appId: appId, // 必填，公众号的唯一标识 timestamp: timestamp, // 必填，生成签名的时间戳 nonceStr: nonceStr, // 必填，生成签名的随机串 signature: signature,// 必填，签名，见附录1 jsApiList: ['closeWindow'] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2&#125;);wx.ready(function()&#123; setTimeout(function()&#123; wx.closeWindow(); &#125;,2000);&#125;); 实用的常识 tag不能重复创建，但是给用户可以重复打同一个tag 更改菜单一般五分钟生效，或者重新关注公众号，立马能看到 如果调用js sdk，务必使用https，防止因为安全问题，导致ios下js下载失败。如果你的服务是https，而引用了https的微信js，在ios下肯定会下载失败，这是ios的安全机制导致的。 微信关闭窗口的js接口，不管jsconfig验证是否通过，窗口都可以关闭 微信的token过期时间上2h，但是很多时候30分钟不到可能已经失效，建议把token过期时间设置为10分钟之内 常见报错 创建菜单的时候，菜单长度不合法，仔细检查自己传的json菜单，一般都是json格式问题，而不是长度 redirect_uri不合法，是创建授权菜单的redirect_uri和网页授权域名配置不一样 关注公众号，服务端设置的欢迎消息发不过去，如果自己代码无异常，一般是因为token过期 以后遇到其他问题继续补充 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"javacript","slug":"javacript","permalink":"http://zhangfuxin.cn/categories/javacript/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhangfuxin.cn/tags/编程语言/"}],"keywords":[{"name":"javacript","slug":"javacript","permalink":"http://zhangfuxin.cn/categories/javacript/"}]},{"title":"那些年读的书","slug":"mybooks","date":"2017-04-15T06:49:46.000Z","updated":"2019-08-21T15:13:24.132Z","comments":true,"path":"mybooks.html","link":"","permalink":"http://zhangfuxin.cn/mybooks.html","excerpt":"** 那些年读的书：** &lt;Excerpt in index | 首页摘要&gt;人生漫漫，不知不觉读了好多书，此贴只记录自己读过哪些书，不做多余的分析和总结。","text":"** 那些年读的书：** &lt;Excerpt in index | 首页摘要&gt;人生漫漫，不知不觉读了好多书，此贴只记录自己读过哪些书，不做多余的分析和总结。 &lt;The rest of contents | 余下全文&gt; 读过哪些种类的 编程专业类 小说类 励志类 小说 平凡的世界 白鹿原 穆斯林的葬礼 金庸武侠系列 古龙武侠小说 梁羽生武侠小说 余华作品集 雷米小说全集（侦探类） 网络小说： 诛仙， 盗墓笔记， 泡沫之夏， 芈月传， 编程类 java编程思想 effective java java并发编程的艺术 代码整洁之道 黑客与画家 深入浅出nodejs nodejs实战 js高级程序设计 survivejs redux和react中文手册 你不知道的javascript 算法javascript实现 mysql权威指南 mongodb权威指南 mongodb实战第二版 redis入门 经管励志 时间管理 一分钟系列 番茄工作法图解 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"book","slug":"book","permalink":"http://zhangfuxin.cn/categories/book/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://zhangfuxin.cn/tags/学习笔记/"}],"keywords":[{"name":"book","slug":"book","permalink":"http://zhangfuxin.cn/categories/book/"}]},{"title":"免费的开源书籍","slug":"free-books","date":"2016-11-28T16:15:52.000Z","updated":"2019-08-21T15:13:24.124Z","comments":true,"path":"free-books.html","link":"","permalink":"http://zhangfuxin.cn/free-books.html","excerpt":"** 免费的开源书籍：** &lt;Excerpt in index | 首页摘要&gt;国外程序员在 stackoverflow 推荐的程序员必读书籍，中文版。","text":"** 免费的开源书籍：** &lt;Excerpt in index | 首页摘要&gt;国外程序员在 stackoverflow 推荐的程序员必读书籍，中文版。 &lt;The rest of contents | 余下全文&gt; 目录 语言无关 IDE MySQL NoSQL PostgreSQL Web WEB服务器 其它 函数式概念 分布式系统 在线教育 大数据 操作系统 数据库 智能系统 正则表达式 版本控制 程序员杂谈 管理和监控 编程艺术 编译原理 编辑器 计算机图形学 设计模式 软件开发方法 项目相关 语言相关 Android AWK C C# C++ CoffeeScript Dart Elasticsearch Elixir Erlang Fortran Golang Haskell HTML / CSS HTTP iOS Java JavaScript LaTeX LISP Lua Markdown Node.js Perl PHP Python R reStructuredText Ruby Rust Scala Scheme Shell Swift Vim Visual Prolog 语言无关IDE IntelliJ IDEA 简体中文专题教程 MySQL 21分钟MySQL入门教程 MySQL索引背后的数据结构及算法原理 NoSQL Disque 使用教程 Neo4j .rb 中文資源 Neo4j 简体中文手册 v1.8 Redis 命令参考 Redis 设计与实现 The Little MongoDB Book The Little Redis Book 带有详细注释的 Redis 2.6 代码 带有详细注释的 Redis 3.0 代码 PostgreSQL PostgreSQL 8.2.3 中文文档 PostgreSQL 9.3.1 中文文档 Web 3 Web Designs in 3 Weeks Chrome 开发者工具中文手册 Chrome扩展开发文档 Growth: 全栈增长工程师指南 Grunt中文文档 Gulp 入门指南 gulp中文文档 HTTP 接口设计指北 HTTP/2.0 中文翻译 http2讲解 JSON风格指南 Wireshark用户手册 一站式学习Wireshark 关于浏览器和网络的 20 项须知 前端代码规范 及 最佳实践 前端开发体系建设日记 前端资源分享（一） 前端资源分享（二） 正则表达式30分钟入门教程 浏览器开发工具的秘密 移动Web前端知识库 移动前端开发收藏夹 WEB服务器 Apache 中文手册 Nginx开发从入门到精通 (淘宝团队出品) Nginx教程从入门到精通 (PDF版本，运维生存时间出品) 其它 OpenWrt智能、自动、透明翻墙路由器教程 SAN 管理入门系列 Sketch 中文手册 深入理解并行编程 函数式概念 傻瓜函数编程 分布式系统 走向分布式 (PDF) 在线教育 51CTO学院 Codecademy CodeSchool Coursera Learn X in Y minutes (数十种语言快速入门教程) shiyanlou TeamTreeHouse Udacity xuetangX 慕课网 (丰富的移动端开发、php开发、web前端、html5教程以及css3视频教程等课程资源) 极客学院 计蒜客 大数据 Spark 编程指南简体中文版 大型集群上的快速和通用数据处理架构 大数据/数据挖掘/推荐系统/机器学习相关资源 数据挖掘中经典的算法实现和详细的注释 面向程序员的数据挖掘指南 操作系统 Debian 参考手册 Docker —— 从入门到实践 Docker中文指南 Docker入门实战 FreeBSD 使用手册 FreeRADIUS新手入门 Linux Documentation (中文版) Linux Guide for Complete Beginners Linux 构建指南 Linux 系统高级编程 Linux工具快速教程 Mac 开发配置手册 Operating Systems: Three Easy Pieces The Linux Command Line (中英文版) Ubuntu 参考手册 uCore Lab: Operating System Course in Tsinghua University UNIX TOOLBOX 命令行的艺术 嵌入式 Linux 知识库 (eLinux.org 中文版) 开源世界旅行手册 深入分析Linux内核源码 理解Linux进程 鸟哥的 Linux 私房菜 基础学习篇 鸟哥的 Linux 私房菜 服务器架设篇 数据库 Redis 设计与实现 The Little MongoDB Book 中文版 智能系统 一步步搭建物联网系统 正则表达式 正则表达式30分钟入门教程 版本控制 Git - 简易指南 Git-Cheat-Sheet （感谢 @flyhigher139 翻译了中文版） Git Community Book 中文版 git-flow 备忘清单 Git magic Git Magic Git 参考手册 Github帮助文档 GitHub秘籍 Git教程 （本文由 @廖雪峰 创作，如果觉得本教程对您有帮助，可以去 iTunes 购买） Got GitHub GotGitHub HgInit (中文版) Mercurial 使用教程 Pro Git Pro Git 中文版 (整理在gitbook上) svn 手册 学习 Git 分支 (点击右下角按钮可切换至简体及正体中文) 沉浸式学 Git 猴子都能懂的GIT入门 程序员杂谈 程序员的自我修养 管理和监控 ElasticSearch 权威指南 Elasticsearch 权威指南（中文版） ELKstack 中文指南 Logstash 最佳实践 Mastering Elasticsearch(中文版) Puppet 2.7 Cookbook 中文版 编程艺术 取悦的工序：如何理解游戏 (豆瓣阅读，免费书籍) 每个程序员都应该了解的内存知识(译)【第一部分】 程序员编程艺术 编程入门指南 编译原理 《计算机程序的结构和解释》公开课 翻译项目 编辑器 exvim–vim 改良成IDE项目 Vim中文文档 所需即所获：像 IDE 一样使用 vim 笨方法学Vimscript 中译本 计算机图形学 OpenGL 教程 设计模式 史上最全设计模式导学目录 图说设计模式 软件开发方法 傻瓜函数编程 (《Functional Programming For The Rest of Us》中文版) 硝烟中的 Scrum 和 XP 项目相关 GNU make 指南 Gradle 2 用户指南 Gradle 中文使用文档 Joel谈软件 selenium 中文文档 开源软件架构 持续集成（第二版） (译言网) 約耳談軟體(Joel on Software) 编码规范 让开发自动化系列专栏 追求代码质量 语言相关Android Android Design(中文版) Android Note(开发过程中积累的知识点) Android6.0新特性详解 Android学习之路 Android开发技术前线(android-tech-frontier) Google Android官方培训课程中文版 Google Material Design 正體中文版 (译本一 译本二) Material Design 中文版 Point-of-Android Android 一些重要知识点解析整理 AWK awk中文指南 awk程序设计语言 C C 语言常见问题集 C/C++ 学习教程 Linux C 编程一站式学习 新概念 C 语言教程 C Sharp 精通C#(第6版) C++ 100个gcc小技巧 100个gdb小技巧 C 语言编程透视 C/C++ Primer - @andycai C++ FAQ LITE(中文版) C++ Primer 5th Answers C++ Template 进阶指南 C++ 基础教程 C++ 并发编程(基于C++11) C++ 并发编程指南 CGDB中文手册 Cmake 实践 (PDF版) GNU make 指南 Google C++ 风格指南 QT 教程 ZMQ 指南 像计算机科学家一样思考（C++版) (《How To Think Like a Computer Scientist: C++ Version》中文版) 简单易懂的C魔法 跟我一起写Makefile(PDF) (PDF) CoffeeScript CoffeeScript 中文 CoffeeScript 编程风格指南 Dart Dart 语言导览 Elasticsearch Elasticsearch 权威指南 （《Elasticsearch the definitive guide》中文版） ELKstack 中文指南 Mastering Elasticsearch(中文版) Elixir Elixir Getting Started 中文翻译 Elixir 编程语言教程 (Elixir School) Elixir元编程与DSL 中文翻译 Phoenix 框架中文文档 Erlang Erlang 并发编程 (《Concurrent Programming in Erlang (Part I)》中文版) Fortran Fortran77和90/95编程入门 Golang Effective Go Go Web 编程 Go 入门指南 (《The Way to Go》中文版) Go 官方文档翻译 Go 指南 (《A Tour of Go》中文版) Go 简易教程 (《The Little Go Book》中文版) Go 编程基础 Go 语言标准库 Go命令教程 Go实战开发 Go语言博客实践 Java程序员的Golang入门指南 Network programming with Go 中文翻译版本 Revel 框架手册 学习Go语言 Groovy 实战 Groovy 系列 Haskell Haskell 趣学指南 Real World Haskell 中文版 HTML / CSS CSS3 Tutorial 《CSS3 教程》 CSS参考手册 Emmet 文档 HTML5 教程 HTML和CSS编码规范 Sass Guidelines 中文 前端代码规范 (腾讯 AlloyTeam 团队) 学习CSS布局 通用 CSS 笔记、建议与指导 iOS Apple Watch开发初探 Google Objective-C Style Guide 中文版 iOS7人机界面指南 iOS开发60分钟入门 iPhone 6 屏幕揭秘 网易斯坦福大学公开课：iOS 7应用开发字幕文件 Java Activiti 5.x 用户指南 Apache MINA 2 用户指南 Apache Shiro 用户指南 Google Java编程风格指南 H2 Database 教程 Java Servlet 3.1 规范 Java 编码规范 Jersey 2.x 用户指南 JSSE 参考指南 MyBatis中文文档 Netty 4.x 用户指南 Netty 实战(精髓) REST 实战 Spring Boot参考指南 (翻译中) Spring Framework 4.x参考文档 用jersey构建REST服务 Javascript Airbnb JavaScript 规范 AngularJS AngularJS中译本 AngularJS入门教程 AngularJS最佳实践和风格指南 在Windows环境下用Yeoman构建AngularJS项目 构建自己的AngularJS backbone.js backbone.js中文文档 backbone.js入门教程 (PDF) Backbone.js入门教程第二版 Developing Backbone.js Applications(中文版) Chrome扩展及应用开发 CoffeeScript CoffeeScript 编码风格指南 D3.js D3.js 入门系列 (还有进阶、高级等系列) 官方API文档 张天旭的D3教程 楚狂人的D3教程 ECMAScript 6 入门 (作者：阮一峰) ExtJS Ext4.1.0 中文文档 Google JavaScript 代码风格指南 Google JSON 风格指南 impress.js impress.js的中文教程 JavaScript Promise迷你书 Javascript 原理 JavaScript 标准参考教程（alpha） 《JavaScript 模式》 “JavaScript patterns”中译本 javascript 的 12 个怪癖 JavaScript 秘密花园 JavaScript核心概念及实践 (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者) Javascript编程指南 (源码) jQuery How to write jQuery plugin 简单易懂的JQuery魔法 Meteor Discover Meteor Node.js express.js 中文文档 Express框架 koa 中文文档 Learn You The Node.js For Much Win! (中文版) Node debug 三法三例 Node.js Fullstack《從零到一的進撃》 Node.js 包教不包会 Nodejs Wiki Book (繁体中文) nodejs中文文档 Node入门 七天学会NodeJS 使用 Express + MongoDB 搭建多人博客 React.js Learn React &amp; Webpack by building the Hacker News front page React Native 中文文档(含最新Android内容) React webpack-cookbook React 入门教程 React.js 中文文档 underscore.js Underscore.js中文文档 You-Dont-Know-JS (深入JavaScript语言核心机制的系列图书) Zepto.js Zepto.js 中文文档 命名函数表达式探秘 (注:原文由为之漫笔 翻译，原始地址无法打开，所以此处地址为我博客上的备份) 学用 JavaScript 设计模式 (开源中国) 深入理解JavaScript系列 LaTeX LaTeX 笔记 一份不太简短的 LaTeX2ε 介绍 大家來學 LaTeX (PDF) LISP ANSI Common Lisp 中文翻译版 Common Lisp 高级编程技术 (《On Lisp》中文版) Lua Lua 5.3 参考手册 Markdown Markdown 快速入门 Markdown 简明教程 Markdown 语法说明 献给写作者的 Markdown 新手指南 Node.js Node 入门 The NodeJS 中文文档（社区翻译） 七天学会NodeJS 阿里出品，很好的入门资料 Perl Master Perl Today 《Modern Perl》中文版 Perl 5 教程 Perl 教程 PHP PHP 之道 PHP5中文手册 PHP扩展开发及内核应用 Symfony2 实例教程 深入理解 PHP 内核 Python Django book 2.0 Python 3 文档(简体中文) 3.2.2 documentation Python 中文学习大本营 深入 Python 3 笨办法学 Python R 153分钟学会 R (PDF) 《R for beginners》中文版 (PDF) R 导论 (《An Introduction to R》中文版) (PDF) 用 R 构建 Shiny 应用程序 (《Building ‘Shiny’ Applications with R》中文版) 统计学与 R 读书笔记 (PDF) reStructuredText reStructuredText 入门 reStructuredText 简明教程 Ruby Rails 风格指南 Ruby on Rails Tutorial 原书第 2 版 Ruby on Rails 实战圣经 Ruby 风格指南 笨方法学 Ruby Rust Rust 官方教程 Rust 语言学习笔记 RustPrimer 通过例子学习 Rust Scala Effective Scala Scala 初学者指南 (The Neophyte’s Guide to Scala) Scala 课堂 (Twitter的Scala中文教程) Scheme Scheme 入门教程 (《Yet Another Scheme Tutorial》中文版) Shell Shell 编程基础 Shell 脚本编程30分钟入门 The Linux Command Line 中文版 Swift 《The Swift Programming Language》中文版 Vim Vim Manual(中文版) 大家來學 VIM Visual Prolog Visual Prolog 7初学指南 Visual Prolog 7边练边学 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"资源分享","slug":"资源分享","permalink":"http://zhangfuxin.cn/categories/资源分享/"}],"tags":[{"name":"book","slug":"book","permalink":"http://zhangfuxin.cn/tags/book/"}],"keywords":[{"name":"资源分享","slug":"资源分享","permalink":"http://zhangfuxin.cn/categories/资源分享/"}]},{"title":"hexo配置和优化记录","slug":"hexo-config","date":"2016-11-28T15:07:12.000Z","updated":"2019-08-21T15:13:24.126Z","comments":true,"path":"hexo-config.html","link":"","permalink":"http://zhangfuxin.cn/hexo-config.html","excerpt":"** hexo配置和优化高级篇：** &lt;Excerpt in index | 首页摘要&gt;本文章不讲解hexo的基础配置，只针对hexo的高级配置，性能优化，seo配置进行讲解。","text":"** hexo配置和优化高级篇：** &lt;Excerpt in index | 首页摘要&gt;本文章不讲解hexo的基础配置，只针对hexo的高级配置，性能优化，seo配置进行讲解。 &lt;The rest of contents | 余下全文&gt; 前言仔细想想，使用hexo搭建博客也有半年多了，但是发现访问量一直几乎没有，特别是经历几次迁移之后，之前从github到coding，现在迁移到了云服务器，研究了一下如何进行seo和网站性能优化，便有了这篇文章。 实用的功能 站内搜索（百度的） 本地搜索（本地插件） 网站统计 留言功能 rss订阅功能 性能优化 html压缩 css压缩 js压缩· img压缩 nginx代理，开启gzip压缩 cdn代理css和图·片 删除主题无用的js和css seo优化 sitemap 对于没有价值的外链a标签添加rel=&quot;external nofollow&quot; 使用meta标签 使用robots文件 主动提交sitemap到搜索引擎 添加外链和内链 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://zhangfuxin.cn/tags/hexo/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}]},{"title":"ubuntu服务器详细配置","slug":"server-config","date":"2016-11-28T12:36:03.000Z","updated":"2019-08-21T15:13:24.137Z","comments":true,"path":"server-config.html","link":"","permalink":"http://zhangfuxin.cn/server-config.html","excerpt":"** ubuntu服务器私人定制：** &lt;Excerpt in index | 首页摘要&gt;把ubuntu服务器打造成自己的个性服务器，装逼必备！！！","text":"** ubuntu服务器私人定制：** &lt;Excerpt in index | 首页摘要&gt;把ubuntu服务器打造成自己的个性服务器，装逼必备！！！ &lt;The rest of contents | 余下全文&gt; ## 说明此教程针对Ubuntu14,其他版本仅作参考 ## 用户密码管理sudo passwd root 添加一个用户组并指定id为1002sudo groupadd －g 1002 www 添加一个用户到www组并指定id为1003sudo useradd wyx -g 1002 -u 1003 -m 修改用户的密码sudo passwd wyx 删除一个用户sudo userdel wyx 为该用户添加sudo权限 12sudo usermod -a -G adm wyxsudo usermod -a -G sudo wyx 查看所有用户和用户组：12cat /etc/passwdcat /etc/group 安装nodejs 安装nvmcurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash 安装nodenvm install v4.4.4,安装nvm install v6.9.1 设置默认的node版本nvm alias default v4.4.4 安装npm3 npm install -g npm@3 设置淘宝的cnpm源 npm install -g cnpm --registry=https://registry.npm.taobao.org 验证安装node -v,npm -v,cnpm -v安装node常用包 安装pm2cnpm install -g pm2 安装hexo博客cnpm install -g hexo-cli 安装同步插件rsynccnpm install -g rsync 安装docker apt安装 1234sudo apt-get updatesudo apt-get install -y docker.iosudo ln -sf /usr/bin/docker.io /usr/local/bin/dockersudo sed -i '$acomplete -F _docker docker' /etc/bash_completion.d/docker.io 源码安装最新版本 12345sudo apt-get install apt-transport-httpssudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9sudo bash -c \"echo deb https://get.docker.io/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list\"sudo apt-get updatesudo apt-get install lxc-docker 验证安装版本docker -v 安装nginxsudo apt-get install nginx启动和配置nginx 安装redissudo apt-get install redis-server启动和配置文件: 安装mongodb 安装3.0 1234apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10echo \"deb http://repo.mongodb.org/apt/debian wheezy/mongodb-org/3.0 main\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.0.listapt-get update apt-get install mongodb-org 安装3.2最新版 1234sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927echo \"deb http://repo.mongodb.org/apt/ubuntu \"$(lsb_release -sc)\"/mongodb-org/3.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb.listsudo apt-get updatesudo apt-get install mongodb-org 制定版本apt-get install mongodb-org=3.2.0 mongodb-org-server=3.2.0 mongodb-org-shell=3.2.0 mongodb-org-mongos=3.2.0 mongodb-org-tools=3.2.0 启动服务 12sudo service mongod startsudo service mongod stop 验证安装mongod --version 配置 安装jdk安装jdk1.7sudo apt-get install openjdk-7-jdk源码安装 1234567891011sudo mkdir /usr/lib/jvmsudo tar zxvf jdk-7u21-linux-i586.tar.gz -C /usr/lib/jvmcd /usr/lib/jvmsudo mv jdk1.7.0_21 javasudo vim ~/.bashrcexport JAVA_HOME=/usr/lib/jvm/javaexport JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 安装mysql实用ubuntu自带的工具下载sudo apt-get install mysql-server 环境变量常见的方法有两种。 在用户主目录下有一个 .bashrc 文件，可以在此文件中加入 PATH 的设置如下：export PATH=”$PATH:/your path1/:/your path2/…..” 在 /etc/profile中增加 PATH=\"$PATH:/home/zhengb66/bin\" export PATH 开机自启动 方法一，编辑rc.loacl脚本Ubuntu开机之后会执行/etc/rc.local文件中的脚本，所以我们可以直接在/etc/rc.local中添加启动脚本。当然要添加到语句：exit 0 前面才行。代码如下:sudo vi /etc/rc.local然后在 exit 0 前面添加好脚本代码。 方法二，添加一个Ubuntu的开机启动服务。如果要添加为开机启动执行的脚本文件，可先将脚本复制或者软连接到/etc/init.d/目录下，然后用：update-rc.d xxx defaults NN命令(NN为启动顺序)，将脚本添加到初始化执行的队列中去。注意如果脚本需要用到网络，则NN需设置一个比较大的数字，如99。1) 将你的启动脚本复制到 /etc/init.d目录下以下假设你的脚本文件名为 test。2) 设置脚本文件的权限 代码如下:sudo chmod 755 /etc/init.d/test3) 执行如下命令将脚本放到启动脚本中去：代码如下:cd /etc/init.d sudo update-rc.d test defaults 95 注：其中数字95是脚本启动的顺序号，按照自己的需要相应修改即可。在你有多个启动脚本，而它们之间又有先后启动的依赖关系时你就知道这个数字的具体作用了。该命令的输出信息参考如下：卸载启动脚本的方法：代码如下:cd /etc/init.dsudo update-rc.d -f test remove 定时任务在Ubuntu下，cron是被默认安装并启动的。通过查看/etc/crontab推荐使用crontab -e命令添加自定义的任务（编辑的是/var/spool/cron下对应用户的cron文件，在/var/spool/cron下的crontab文件 不可以直接创建或者直接修改，crontab文件是通过crontab命令得到的）。crontab -e 直接执行命令行每2分钟打印一个字符串“Hello World”，保存至文件/home/laigw/cron/HelloWorld.txt中，cron 格式如下：*/2 * * * * echo “Hello World.” &gt;&gt; /home/HelloWorld.txt shell 文件每3分钟调用一次 /home/laigw/cron/test.sh 文件，cron 格式如下：*/3 * * * * /home/laigw/cron/test.sh ftp和rsync配置 持续集成环境 jenkens配置 gitlab配置 git服务器 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://zhangfuxin.cn/tags/linux/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}]},{"title":"mac开发环境配置","slug":"mac-dev","date":"2016-11-27T07:52:38.000Z","updated":"2019-08-21T15:13:24.130Z","comments":true,"path":"mac-dev.html","link":"","permalink":"http://zhangfuxin.cn/mac-dev.html","excerpt":"** mac开发环境配置：** &lt;Excerpt in index | 首页摘要&gt;工欲善其事，必先利其器，做好开发者，先搞好开发环境啊。针对mac开发者的开发配置，把mac打造成最具生产力工具！","text":"** mac开发环境配置：** &lt;Excerpt in index | 首页摘要&gt;工欲善其事，必先利其器，做好开发者，先搞好开发环境啊。针对mac开发者的开发配置，把mac打造成最具生产力工具！ &lt;The rest of contents | 余下全文&gt; 软件下载说明下面所提到的软件，有很多需要付费或者破解版，为了方便大家使用，会在网盘分享给大家，只需在评论的地方留下自己的百度云账号！！！ 软件分类说明 通用（开发者必备的软件） java类（java开发者必不可少） 前端类（偏前端和nodejs） python类 数据库类 其他（php，ruby等等） 通用软件 Alfred dash homebrew zsh（oh my zsh） sublime text3, vscode paste(剪切板工具) BetterSnapTool(分屏软件) cornerstone(svn) tower(git) alternote() paw chrome firefox pdf expert CheatSheet snippetslab java软件 jdk idea eclipse maven zookeeper,dubbo tomcat apache 前端必备 nvm(nodejs,npm,cnpm) webpack yo webstorm python必备 pycharm sublime text（插件） 数据库类 mysql mongodb sqllite navicate robomongo redis 其他软件 office keynote,pages,number photoshop 文章长期更新，请收藏 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://zhangfuxin.cn/tags/mac/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}]},{"title":"atom中最好的js代码补全","slug":"best-js-snippet","date":"2016-07-21T22:11:30.000Z","updated":"2019-08-21T15:13:24.119Z","comments":true,"path":"best-js-snippet.html","link":"","permalink":"http://zhangfuxin.cn/best-js-snippet.html","excerpt":"** atom中最好的js代码补全：** &lt;Excerpt in index | 首页摘要&gt; 这或许是atom中最好的js代码补全,包含了express,nodejs,es6,目前仍在继续更新","text":"** atom中最好的js代码补全：** &lt;Excerpt in index | 首页摘要&gt; 这或许是atom中最好的js代码补全,包含了express,nodejs,es6,目前仍在继续更新 &lt;The rest of contents | 余下全文&gt; best-js-snippets这个package的名字就叫 best-js-snippets ,用atom的可以下载使用一下,提出建议,我会尽快修改 特性 express补全 es6补全 js补全(string,dom操作) nodejs补全(fs,event,util,module,class,assert) 如何安装 atom编辑器中找到设置,搜索package,安装即可. 重启atom,享受吧! 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}],"tags":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/tags/others/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}]},{"title":"常用排序算法学习","slug":"sort-study","date":"2016-07-08T14:39:24.000Z","updated":"2019-08-21T15:13:24.138Z","comments":true,"path":"sort-study.html","link":"","permalink":"http://zhangfuxin.cn/sort-study.html","excerpt":"** 常用排序算法学习：** &lt;Excerpt in index | 首页摘要&gt; 程序员各种排序算法，算法的实现和分析","text":"** 常用排序算法学习：** &lt;Excerpt in index | 首页摘要&gt; 程序员各种排序算法，算法的实现和分析 &lt;The rest of contents | 余下全文&gt; 排序算法的分类 排序分内排序和外排序。 内排序:指在排序期间数据对象全部存放在内存的排序。 外排序:指在排序期间全部对象个数太多,不能同时存放在内存,必须根据排序过程的要求,不断在内、外存之间移动的排序。 内排序的方法有许多种,按所用策略不同,可归纳为五类:插入排序、选择排序、交换排序、归并排序、分配排序和计数排序。 插入排序主要包括直接插入排序，折半插入排序和希尔排序两种; 选择排序主要包括直接选择排序和堆排序; 交换排序主要包括冒泡排序和快速排序; 归并排序主要包括二路归并(常用的归并排序)和自然归并。 分配排序主要包括箱排序和基数排序 冒泡排序 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不用交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法1234567891011121314151617// js代码function sort(arr) &#123;if (arr.length == 0) &#123; return [];&#125;var length = arr.length;for (var i = 0; i &lt; length; i++) &#123; for (var j = 0; j &lt; length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; console.log(arr); &#125; &#125; &#125;&#125; 快速排序 快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列. 时间复杂度：O（nlgn）最坏：O（n^2）空间复杂度：O（nlgn） 1234567891011121314151617181920212223// js递归实现function quickSort(arr) &#123; if (arr.length == 0) &#123; return []; &#125; var left = []; var right = []; var pivot = arr[0]; for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat(pivot, quickSort(right));&#125;var a = [];for (var i = 0; i &lt; 10; ++i) &#123; a[i] = Math.floor((Math.random() * 100) + 1);&#125;console.log(a);console.log(quickSort(a)); 直接插入排序 直接插入排序(straight insertion sort)的作法是：每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序. 12345678910111213141516171819function insertionSort(arr) &#123; var temp, inner; for (var outer = 1; outer &lt;= arr.length - 1; ++outer) &#123; temp = arr[outer]; inner = outer; while (inner &gt; 0 &amp;&amp; (arr[inner - 1] &gt;= temp)) &#123; arr[inner] = arr[inner - 1]; --inner; &#125; arr[inner] = temp; &#125; return arr;&#125;var a = [];for (var i = 0; i &lt; 10; ++i) &#123; a[i] = Math.floor((Math.random() * 100) + 1);&#125;console.log(a);console.log(insertionSort(a)); 折半插入排序 折半插入排序算法的具体操作为：在将一个新元素插入已排好序的数组的过程中，寻找插入点时，将待插入区域的首元素设置为a[low],末元素设置为 a[high]，则轮比较时将待插入元素与a[m],其中m=(low+high)/2相比较,如果比参考元素小，则选择a[low]到a[m-1]为新 的插入区域(即high=m-1)，否则选择a[m+1]到a[high]为新的插入区域（即low=m+1），如此直至low&lt;=high不成 立，即将此位置之后所有元素后移一位，并将新元素插入a[high+1] 希尔排序 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为dl的倍数的记录放在同一个组中。先在各组内进行直接插入 排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1(dt&lt;dt-l&lt;…&lt;d2&lt;d1)， 即所有记录放在同一组中进行直接插入排序为止。 该方法实质上是一种分组插入方法。插入排序（Insertion Sort）的一个重要的特点是，如果原始数据的大部分元素已经排序，那么插入排序的速度很快（因为需要移动的元素很少）。从这个事实我们可以想到，如果原 始数据只有很少元素，那么排序的速度也很快。－－希尔排序就是基于这两点对插入排序作出了改进。 直接选择排序 直接选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。时间复杂度是O(n^2) 堆排序 我们知道堆的结构是节点i的孩子为2i和2i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。 二路归并排序 归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhangfuxin.cn/tags/算法/"}],"keywords":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangfuxin.cn/categories/algorithm/"}]},{"title":"mysql优化的常用方法","slug":"mysql-optimize","date":"2016-06-10T23:25:13.000Z","updated":"2019-08-21T15:13:24.133Z","comments":true,"path":"mysql-optimize.html","link":"","permalink":"http://zhangfuxin.cn/mysql-optimize.html","excerpt":"** mysql优化：** &lt;Excerpt in index | 首页摘要&gt; mysql的优化措施，从sql优化做起","text":"** mysql优化：** &lt;Excerpt in index | 首页摘要&gt; mysql的优化措施，从sql优化做起 &lt;The rest of contents | 余下全文&gt; 优化sql的一般步骤 通过show status了解各种sql的执行频率 定位执行效率低的sql语句 通过explain分析效率低的sql 通过show profile分析sql 通过trace分析优化器如何选择执行计划 确定问题，采取措施优化 索引优化措施 mysql中使用索引的典型场景 匹配全值，条件所有列都在索引中而且是等值匹配 匹配值的范围查找，字段必须在索引中 匹配最左前缀，复合索引只会根据最左列进行查找 仅仅对索引进行查询，即查询的所有字段都在索引上 匹配列前缀，比如like ‘ABC%’,如果是like ‘%aaa’就不可以 如果列名是索引，使用column is null会使用索引 存在索引但不会使用索引的典型场景 以%开头的like查询不能使用b树索引 数据类型出现隐式转换不能使用索引 复合索引，查询条件不符合最左列原则 用or分割的条件，如果前面的条件有索引，而后面的条件没有索引 查看索引使用的情况 1show status like &apos;Handler_read%&apos;; 如果Handler_read_rnd_next的值比较高，说明索引不正确或者查询没有使用到索引 简单实用的优化方法 定期检查表和分析表分析表语法：1analyze table 表名； 检查表语法： 1check table 表名； 定期优化表 对于字节大小不固定的字段，数据更新和删除会造成磁盘空间不释放，这时候就行优化表，可以整理磁盘碎片，提高性能语法如下：1optimize table user(表名)； 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://zhangfuxin.cn/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}]},{"title":"mac下mysql5.6字符集设置","slug":"mac-mysql-unicode","date":"2016-05-28T15:10:37.000Z","updated":"2019-08-21T15:13:24.130Z","comments":true,"path":"mac-mysql-unicode.html","link":"","permalink":"http://zhangfuxin.cn/mac-mysql-unicode.html","excerpt":"** mac下mysql5.6字符集设置：** &lt;Excerpt in index | 首页摘要&gt; 在mac下设置mysql5.6字符集时踩过的坑，百分百保证有效","text":"** mac下mysql5.6字符集设置：** &lt;Excerpt in index | 首页摘要&gt; 在mac下设置mysql5.6字符集时踩过的坑，百分百保证有效 &lt;The rest of contents | 余下全文&gt; 为什么要设置字符集 设置字符集主要是解决乱码问题，由于中文和英文编码不同导致，中文出现乱码，所以一般都设置为utf8格式 不同的字符集和编码占用的字节不同，选择适合的编码会提高数据库性能 mac下设置 在/etc/my.cnf文件进行设置，如果没有此文件可以从/usr/local/mysql/support-files/拷贝，命令如下12cd /usr/local/mysql/support-filessudo cp my.cnf /etc/my.cnf 查看文件的读写权限，如果为644（rw- r– r–）则改为(664) (rw- rw- r–)如果改为(666)(rw- rw- rw-)则修改以后配置文件不会生效 1sudo chmod 664 /etc/my.cnf my.cnf设置如下：12345678[client]default-character-set=utf8[mysqld]collation-server = utf8_unicode_ciinit-connect=&apos;SET NAMES utf8&apos;character-set-server = utf8[mysql]default-character-set=utf8 查看设置是否成功在命令行输入mysql，如果提示没有命令的话，在bash或者zsh的文件里修改，我用的是zsh，设置~/.zshrc, 12export MYSQL=&quot;/usr/local/mysql/bin/&quot;export PATH=&quot;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:$MYSQL&quot; 在命令行输入mysql,进入mysql命令行后，输入status;或者show variables like &#39;%char%&#39;; 12345678| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/local/mysql-5.6.30-osx10.11-x86_64/share/charsets/ 博客搬家，请访问新博客地址吧! 我的博客","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://zhangfuxin.cn/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}]},{"title":"mysql学习笔记","slug":"mysql-study","date":"2016-05-28T14:24:56.000Z","updated":"2019-08-21T15:13:24.133Z","comments":true,"path":"mysql-study.html","link":"","permalink":"http://zhangfuxin.cn/mysql-study.html","excerpt":"** mysql学习笔记：** &lt;Excerpt in index | 首页摘要&gt; mysql学习，基础的增删改查，数据库优化，索引，分片，集群搭建等等。","text":"** mysql学习笔记：** &lt;Excerpt in index | 首页摘要&gt; mysql学习，基础的增删改查，数据库优化，索引，分片，集群搭建等等。 &lt;The rest of contents | 余下全文&gt; mysql的特点 关系型数据库，免费使用， 插入式存储引擎， 性能高， 基础的增删改查 ddl语句，数据定义语句 123456789101112create database test1;drop database test1;use test1;create table emp(ename varchar(10),hiredate date,sal decimal(10,2),deptno int(2));drop table emp;alter table emp modify ename varchar(20);alter table emp add column age int(3);alter table emp drop column age;alter table emp change age age1 int(4);alter table emp add birth date after ename;alter table emp modify age int(3) first;alter table emp rename emp1; dml语句，数据操纵语句 123456789101112insert into emp(ename,hiredate,sal,deptno) values(&apos;zzx1&apos;,&apos;2000-10-11&apos;,2000,1);insert into emp values(&apos;lisa&apos;,&apos;2004-05-09&apos;,3000,2);insert into dept values(5,&apos;dept5&apos;),(6,&apos;dept6&apos;);update emp set sal=4000 where ename=&apos;lisa&apos;;update emp a,dept b set a.sal=a.sal*b.deptno,b.deptname=a.ename where a.deptno=b.deptno;delete from emp where ename=&apos;dony&apos;;delete a,b from emp a,dept b where a.deptno=b.deptno and a.deptno=3;select * from emp where ename=&apos;lisa&apos;;select distinct deptno from emp;select * from emp order by sal(desc);select * from emp order by sal limit 5;select * from emp order by sal limit 1,5;ss dcl语句，数据控制语句 sql优化 尽量使用 prepareStatement(java)，利用预处理功能。 在进行多条记录的增加、修改、删除时，建议使用批处理功能，批处理的次数以整个 SQL 语句不超过相应数据库的 SQL 语句大小的限制为准。 建议每条 SQL 语句中 in 中的元素个数在 200 以下，如果个数超过时，应拆分为多条 SQL 语句。禁止使用 xx in(‘’,’’….) or xx in(‘’,’’,’’)。 ★ 禁止使用 or 超过 200，如 xx =’123’ or xx=’456’。 ★ 尽量不使用外连接。 禁止使用 not in 语句，建议用 not exist。 ★ 禁止使用 Union, 如果有业务需要，请拆分为两个查询。 ★ 禁止在一条 SQL 语句中使用 3 层以上的嵌套查询，如果有，请考虑使用临时表或中间结果集。 尽量避免在一条 SQL 语句中从&gt;= 4 个表中同时取数， 对于仅是作为过滤条件关联，但不涉及取数的表，不参与表个数计算 查询条件里任何对列的操作都将导致表扫描，所以应尽量将数据库函数、计算表达式写在逻辑操作符右边。 在对 char 类型比较时,建议不要使用 rtrim()函数,应该在程序中将不足的长度补齐。 用多表连接代替 EXISTS 子句。 如果有多表连接时， 应该有主从之分， 并尽量从一个表取数， 如 select a.col1, a.col2from a join b on a.col3=b.col4 where b.col5 = ‘a’。 在使用 Like 时，建议 Like 的一边是字符串，表列在一边出现。 不允许将 where 子句的条件放到 having 中。 将更新操作放到事务的最后执行。如 一个事务需更新多个对象时，需保证更新的顺序一致以避免死锁的发生。如总是先更新子表再更新主表，根据存货档案批量更新现存量时，对传入的存货档案 PK 进行排序，再做更新处理等。 禁止随意使用临时表，在临时数据不超过 200 行的情况下禁止使用临时表。 禁止随意使用 distinct，避免造成不必要的排序。 索引优化 创建索引，删除索引 12create index cityname on city(city(10));drop index cityname on city; 搜索的索引列最好在where的字句或者连接子句 使用唯一索引 使用短索引，对于较长的字段，使用其前缀做索引 不要过度使用索引，索引引起额外的性能开销和维护 高级优化措施集群搭建","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://zhangfuxin.cn/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}]},{"title":"nodejs开发规范","slug":"node-develop","date":"2016-05-23T06:18:02.000Z","updated":"2019-08-21T15:13:24.134Z","comments":true,"path":"node-develop.html","link":"","permalink":"http://zhangfuxin.cn/node-develop.html","excerpt":"** nodejs开发规范：** &lt;Excerpt in index | 首页摘要&gt; nodejs开发中应当遵循的规范，以及最佳实践","text":"** nodejs开发规范：** &lt;Excerpt in index | 首页摘要&gt; nodejs开发中应当遵循的规范，以及最佳实践 &lt;The rest of contents | 余下全文&gt; node开发需要编程规范吗？ js的灵活性非常大，如果开发人员每个人都按自己的习惯随意编写，js的代码会非常混乱不堪。js程序员需要更强的自律性和规范，才能写出易读性，易维护的代码。 随着前端mvc的崛起，前端的js代码会更加庞大难以管理，如果没有统一的规范，后期维护会比登天还难。 编码规范 缩进采用两个空格缩进，在编辑器中设置tab为两个空格 变量声明 用var声明变量var assert = require(‘assert’);var fork = require(‘child_process’).fork;var net = require(‘net’); 错误实例：var assert = require(‘assert’), fork = require(‘child_process’).fork, net = require(‘net’)； 用字面量声明方式var num = 123;var aaa = {};var arr = [];var isAdmin = true; 避免使用：var obj =new Object();var arr = new Array();var test =new String(“”);var size = new Number(); 不要在for循环等循环里声明var变量首先var是函数作用域，在循环声明以后只有等函数声明周期结束这些资源才会释放 空格在操作符前后需要加上空格,= 、% 、* 、- 、+ 前后都应该加一个空格比如：var foo = ‘bar’ + baz;错误实例：var foo=’bar’+baz; 单双引号的使用在node中尽量使用单引号，var html = ‘CNode‘;在json中使用双引号 分号给表达式结尾加分号，尽管js会自动在行尾加上分号，但是会产生一些误解 命名规范在编码中，命名是重头戏。好的命名可以使代码赏心悦目，具有良好的维护性。 变量命名变量名采用小驼峰命名，单词之间没有任何符号如：var adminUser = {};var callNum = 2134323; 方法命名也是采用小驼峰命名，与变量不同的是采用动词或判断行词汇，如：var getUser = function(){};var isAdmin = function(){};var findUser = function(){}; 类命名类名采用大驼峰，所有单词首字母大写，如：function User{} 常量命名作为常量，单词所有字母大写，用下划线分割，如：var PINK_COLOR = “PINK”; 文件命名命名文件时，尽量使用下划线分割单词，比如child_process.js和string_decode.js 包名在包名中尽量不要包含js和node的字样，应当适当短并且有意义 其它要点 作用域慎用with和eval（），容易引起作用域混乱 比较操作尽量使用===代替==,否则会遇到下面的情况，’0’==0;//true;‘’==0;//true;‘0’===’’//false; 严格模式在node后台中尽量全使用严格模式‘use strict’; 对象和数组遍历数组遍历使用普通for循环，避免使用for in对数组遍历，对象的遍历使用for in 项目中实践 sublime和webstorm都有JSLint,JSHint这样的代码质量工具，在配置文件中制定好模板规范即可 在版本控制工具中设置hook，在precommit的脚本中设置，如果代码不符合标准，就无法提交 参考文献 深入浅出nodejs js秘密花园 js高级编程","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhangfuxin.cn/categories/编程语言/"}],"tags":[{"name":"node","slug":"node","permalink":"http://zhangfuxin.cn/tags/node/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhangfuxin.cn/categories/编程语言/"}]},{"title":"redis学习笔记","slug":"redis-study","date":"2016-05-23T00:25:57.000Z","updated":"2019-08-21T15:13:24.136Z","comments":true,"path":"redis-study.html","link":"","permalink":"http://zhangfuxin.cn/redis-study.html","excerpt":"** redis学习笔记：** &lt;Excerpt in index | 首页摘要&gt; redis数据库的基本操作，增删改查","text":"** redis学习笔记：** &lt;Excerpt in index | 首页摘要&gt; redis数据库的基本操作，增删改查 &lt;The rest of contents | 余下全文&gt; keysredis本质上是一个key-value数据库 设置：set key value 获取：get key 判断存在：exists key 删除：del key del test:fan:age 重命名：rename oldkey newkey 数量：dbsize 返回数据 获取所有key（通配符）：Keys test:*:ageKeys test:?:age 清空：flushdb flushall 设置有效时间：expire test:fan:age 30 查询有效时间：ttl test:fan:age String类型 设置： set key value setnx ky value(nx是not exist) mset key1 value1 keyN valueN msetnx key1 value1 keyN valueN 获取： get 不存在返回nil getset 设置key的值，并返回key的旧值，不存在返回nil mget 自增减： incr key 对key的值进行++操作，返回新的值 decr key incrby key integer 对key加上一个数值 decrby key integer 截取： substr key indexStart indexEnd 下标从0开始 追加： append key value list类型redis的list其实就是一个每个元素都是string 的双向链表，所以push和pop的时间复杂度都是O（1） 添加 lpush key string 在头部添加 rpush key string 在尾部添加 修改 lset key index value 修改指定下标的key的值 删除 lpop key 从头部返回删除 rpop key 从尾部 lrem key count value 删除count个相同的value，count为0删除全部 blpop key …keyN timeout brpop 从尾部删除 获取 lrange key indexStart indexEnd 数量 llen key 返回key对应的list长度 截取 ltrim key start end 转移 rpoplpush key1 key2 从key1尾部移到key2头部 set集合redis的set就是String的无序集合，通过hashtable实现 添加 sadd key member 删除 srem key member 移除指定的元素 spop key 删除并返回一个随机的 获取 smembers key 返回所有 srandmember 随机取一个不删除 判断存在 sismember key member 数量 scard key 返回元素个数 转移 smove srckey dstkey member 取交集 sinter key1 key2 keyN sinterstore dstkey key1 keyN 将交集存在dstkey 取并集 sunion key1 key2 keyN sunionstore dstkey key1 keyN 将并集存在dstkey 取差集 sdiff key1 key2 keyN sdiffstore dstkey key1 keyN 将差集存在dstkey 有序set类型和set一样，不同的是每个元素关联一个double类型的score，根据score排序，sorted set的实现由skip list和hashtable 添加 zadd key score member 删除 zrem key member zremrangebyrank key min max zremrangebyscore key min max 删除集合score在给定区间的元素 获取 zrange key start end zrevrange key start end 按score的逆序 zrangebyscore key min max 判断存在 zrank key member 返回下标 zrerank key member 返回逆序的下标 数量 zcard key 总数 zcount key min max 区间的数量 修改 zincrby key incr member 增加member的score值并排序 hash类型redis的hash是一个string类型的field和value的映射表，hash特别适合存储对象， 设置： hset key field value hmset key field1 value1 field2 value2 获取： hget key field hmget key field1 field2 判断存在 hexists key field 删除 hdel key field 查找 hkeys key 返回所有 field hvals key 返回所有的value hgetall key 返回所有field和value 数量 hlen key 值加减 hincrby key field integer 将指定的hash field加上定值","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://zhangfuxin.cn/tags/redis/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://zhangfuxin.cn/categories/数据库/"}]},{"title":"git比svn的优势","slug":"git-svn","date":"2016-05-22T03:13:00.000Z","updated":"2019-08-21T15:13:24.126Z","comments":true,"path":"git-svn.html","link":"","permalink":"http://zhangfuxin.cn/git-svn.html","excerpt":"** git比svn的优势：** &lt;Excerpt in index | 首页摘要&gt; 主要介绍svn和git在使用的时候一些区别","text":"** git比svn的优势：** &lt;Excerpt in index | 首页摘要&gt; 主要介绍svn和git在使用的时候一些区别 &lt;The rest of contents | 余下全文&gt; 合并操作时对提交过程的保留 git:合并操作保留原有的提交过程 svn:多个提交合并为一个提交 不用因为合并操作而导致追踪的困难 修正提交 git：可以修正提交。使用功能分支工作流，在自己的分支可以方便修正提交而不会影响大家。 svn：一旦提交就到服务器上，实际使用中就是不能修改（svn可以在服务器上修改，因为过程复杂需要权限实际上从不会这样做） 本地分支 git可以方便的创建本地分支,创建时间极短,分支可以是本地的,不会存在svn中目录权限的问题 强大的合并能力 git：重命名（无论文件还有目录）提交 可以合并上 文件重命名前的这些文件的提交 svn：重命名（无论文件还有目录）提交后，你本地/或是分支上 有文件重命名前的这些文件的修改或提交，在做合并操作时,你会碰上传说中难搞的树冲突！ 这就导致在调整目录名称和类名调整的时候比较繁琐,需要告诉大家,我修改完以后你再修改 tag的支持 svn在模型上是没有分支和tag的。tag是通过目录权限限制（对开发只读）来保证不变。 git模型上一等公民支持tag，保证只读。 速度优势 git的提交是个本地提交,相对svn来说如闪电一般 git提供了暂存区,可以方便制定提交内容,而不是全部内容 日志查看 git：本地包含了完整的日志，闪电的速度（并且无需网络) svn：需要从服务拉取。 一旦用了git后，等待svn日志过程简直让我发狂","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}],"tags":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/tags/others/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}]},{"title":"java和javascript日期详解","slug":"java-date","date":"2016-05-13T13:48:00.000Z","updated":"2019-08-21T15:13:24.128Z","comments":true,"path":"java-date.html","link":"","permalink":"http://zhangfuxin.cn/java-date.html","excerpt":"** java，js日期转换：** &lt;Excerpt in index | 首页摘要&gt; java的各种日期转换","text":"** java，js日期转换：** &lt;Excerpt in index | 首页摘要&gt; java的各种日期转换 &lt;The rest of contents | 余下全文&gt; 日期表示类型 获取long类型的日期格式 1234long time = System.currentTimeMillis();System.out.printf(time+\"\");Date date =new Date();System.out.println(date.getTime()); 获取制定格式的日期 123SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");Date date =new Date();System.out.println(sdf.format(date) ); 把制定格式的日期转为date或者毫秒值 123SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");Date date = sdf.parse(\"2016-05-22 10:15:21\");long mills = date.getTime(); 说明:System.currentTimeMillis()并不能精确到1ms的级别,它取决于运行的系统,你再windows,mac,linux精确的范围都有差异,对于有高精度时间的要求,不能使用这个 日期计算 最方便的方式是将时间转为毫秒值进行计算1234Date from =new Date();Thread.sleep(200);//线程休眠2msDate to =new Date();System.out.println(to.getTime()-from.getTime()); 高精度时间12long time1 =System.nanoTime();System.out.printf(time1+\"\"); 说明:System.nanoTime()提高了ns级别的精度,1ms=1000000ns, javascript日期 获取时间的毫秒值，获取月份，时间 1234567891011121314var myDate = new Date();myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期var mytime=myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间 时间戳获取注意，java，php等生成的时间戳是秒，不是毫秒，所以需要签名时间戳的时候，需要转为秒时间戳 12var time = new Date();var timestamp = parseInt(time.getTime()/1000); 格式化时间 12345678910111213141516//获取当前时间，格式YYYY-MM-DDfunction getNowFormatDate() &#123; var date = new Date(); var seperator1 = \"-\"; var year = date.getFullYear(); var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123; month = \"0\" + month; &#125; if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123; strDate = \"0\" + strDate; &#125; var currentdate = year + seperator1 + month + seperator1 + strDate; return currentdate;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhangfuxin.cn/categories/编程语言/"}],"tags":[{"name":"java","slug":"java","permalink":"http://zhangfuxin.cn/tags/java/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhangfuxin.cn/categories/编程语言/"}]},{"title":"制定学习目标和计划","slug":"study-goals","date":"2016-05-06T02:20:45.000Z","updated":"2019-08-21T15:13:24.140Z","comments":true,"path":"study-goals.html","link":"","permalink":"http://zhangfuxin.cn/study-goals.html","excerpt":"** 制定学习目标和计划：** &lt;Excerpt in index | 首页摘要&gt; 近期的学习目标和学习重点,提高自己的能力","text":"** 制定学习目标和计划：** &lt;Excerpt in index | 首页摘要&gt; 近期的学习目标和学习重点,提高自己的能力 &lt;The rest of contents | 余下全文&gt; 找到自己的兴趣 自己主动学习一定要基于自己的兴趣,不要看什么框架流行,什么语言火,就去学,学的不温不火,然后放弃. 一定看自己的兴趣,比如你对色彩,对布局,对特效比较痴迷,那你去css3,html5做出特酷的效果,肯定能让你肯定自己,收获知识和自信. 没有兴趣的时候,可以适当的多接触一些东西,在最短的时间多接触一些领域,让自己的心去做选择, 制定目标 为什么要制定目标? 制定目标是对自己学习能力的检验,同时也是提高学习效率的关键,而不是自己没有目的的瞎看, 如何制定目标? 结合自身的能力,定制比自己能力稍高的目标,这样自己通过一定程度的努力可以实现目标.这样自己的能力能一次一次提高. 及时反馈 古人说的好,吾日三省吾身,对待学习目标也是一样,要时不时的看自己的目标完成的如何,进度如何,是不是需要调整,不能闷着头蛮干,方向错了,再多的努力也是白搭了. 总结 我在刚开始学编程的时候,每天都给自己定制了目标,一天完成多少课时,完成多少练习,都是按量完成,在最初的几个月收到了立竿见影的效果,让我也在短短三个月的时间学会了java,所以,目标的制定对于结果的影响是非常大.","categories":[{"name":"个人随笔","slug":"个人随笔","permalink":"http://zhangfuxin.cn/categories/个人随笔/"}],"tags":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/tags/others/"}],"keywords":[{"name":"个人随笔","slug":"个人随笔","permalink":"http://zhangfuxin.cn/categories/个人随笔/"}]},{"title":"使用ghost搭建个人博客","slug":"ghost-blog","date":"2016-05-03T23:59:22.000Z","updated":"2019-08-21T15:13:24.125Z","comments":true,"path":"ghost-blog.html","link":"","permalink":"http://zhangfuxin.cn/ghost-blog.html","excerpt":"** 使用ghost搭建个人博客：** &lt;Excerpt in index | 首页摘要&gt; 使用ghost搭建个人博客","text":"** 使用ghost搭建个人博客：** &lt;Excerpt in index | 首页摘要&gt; 使用ghost搭建个人博客 &lt;The rest of contents | 余下全文&gt; ghost简介 ghost是轻量级的博客建站工具,使用起来简单,功能强大,适合个人搭建小型网站,个人博客,或者个人展示的网站 ghost基于nodejs,对于熟悉js的前端小伙伴来说,入手起来也是简单不少. 准备工作 安装nodejs 安转git 配置ssh 下载ghost 购买域名 搭建博客定制个人博客享受吧","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}],"tags":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/tags/others/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}]},{"title":"git学习笔记","slug":"git-config-study","date":"2016-05-01T00:24:45.000Z","updated":"2019-08-21T15:13:24.125Z","comments":true,"path":"git-config-study.html","link":"","permalink":"http://zhangfuxin.cn/git-config-study.html","excerpt":"** git学习笔记：** &lt;Excerpt in index | 首页摘要&gt; git的常用操作，高级技巧都要哦","text":"** git学习笔记：** &lt;Excerpt in index | 首页摘要&gt; git的常用操作，高级技巧都要哦 &lt;The rest of contents | 余下全文&gt; 安装git 下载安装包 ￼下载地址￼ 安装git 进入命令行,输入git看看是否成功 配置git 配置全局用户名和密码 `git config –global user.name “John Doe” git config –global user.email johndoe@example.com ` 配置ssh公钥 cd ~/.ssh 然后ls 如果没有,直接生成,一路点击enter ``` ssh-keygen cat ~/.ssh/id_rsa.pub ``` 把公钥配置到github的个人设置 常用的命令 repository操作 检出（clone）仓库代码：git clone repository-url / git clone repository-url local-directoryname 例如，clone jquery 仓库到本地： git clone git://github.com/jquery/jquery.git clone jquery 仓库到本地，并且重命名为 my-jquery ：git clone git://github.com/jquery/jquery.git my-jquery 查看远程仓库：git remote -v 添加远程仓库：git remote add [name] [repository-url] 删除远程仓库：git remote rm [name] 修改远程仓库地址：git remote set-url origin new-repository-url 拉取远程仓库： git pull [remoteName] [localBranchName] 推送远程仓库： git push [remoteName] [localBranchName] 提交/拉取/合并/删除 添加文件到暂存区（staged）：git add filename / git stage filename 将所有修改文件添加到暂存区（staged）： git add --all / git add -A 提交修改到暂存区（staged）：git commit -m &#39;commit message&#39; / git commit -a -m &#39;commit message&#39; 注意理解 -a 参数的意义 从Git仓库中删除文件：git rm filename 从Git仓库中删除文件，但本地文件保留：git rm --cached filename 重命名某个文件：git mv filename newfilename 或者直接修改完毕文件名 ，进行git add -A &amp;&amp; git commit -m &#39;commit message&#39; Git会自动识别是重命名了文件 获取远程最新代码到本地：git pull (origin branchname) 可以指定分支名，也可以忽略。pull 命令自动 fetch 远程代码并且 merge，如果有冲突，会显示在状态栏，需要手动处理。更推荐使用：git fetch 之后 git merge --no-ff origin branchname 拉取最新的代码到本地仓库，并手动 merge 。 日志查看 查看日志：git log 查看日志，并查看每次的修改内容：git log -p 查看日志，并查看每次文件的简单修改状态：git log --stat 一行显示日志：git log --pretty=oneline / git log --pretty=&#39;format:&quot;%h - %an, %ar : %s&#39; 查看日志范围： 查看最近10条日志：git log -10 查看2周前：git log --until=2week 或者指定2周的明确日期，比如：git log --until=2015-08-12 查看最近2周内：git log --since=2week 或者指定2周明确日志，比如：git log --since=2015-08-12 只查看某个用户的提交：git log --committer=user.name / git log --author=user.name 取消操作 上次提交msg错误/有未提交的文件应该同上一次一起提交，需要重新提交备注：git commit --amend -m &#39;new msg&#39; 一次git add -A后，需要将某个文件撤回到工作区，即：某个文件不应该在本次commit中：git reset HEAD filename 撤销某些文件的修改内容：git checkout -- filename 注意：一旦执行，所有的改动都没有了，谨慎！谨慎！谨慎！ 将工作区内容回退到远端的某个版本：git reset --hard &lt;sha1-of-commit&gt; --hard：reset stage and working directory , 以来所有的变更全部丢弃，并将 HEAD 指向 --soft：nothing changed to stage and working directory ,仅仅将HEAD指向 ，所有变更显示在”changed to be committed”中 --mixed：default,reset stage ,nothing to working directory ，这也就是第二个例子的原因 比较差异 查看工作区（working directory）和暂存区（staged）之间差异：git diff 查看工作区（working directory）与当前仓库版本（repository）HEAD版本差异：git diff HEAD 查看暂存区（staged）与当前仓库版本（repository）差异：git diff --cached / git diff --staged 合并操作 解决冲突后/获取远程最新代码后合并代码：git merge branchname 保留该存在版本合并log：git merge --no-ff branchname 参数--no-ff防止 fast-forward 的提交","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://zhangfuxin.cn/categories/学习笔记/"}],"tags":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/tags/others/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://zhangfuxin.cn/categories/学习笔记/"}]},{"title":"ubuntu16服务器环境配置","slug":"ubuntu-dev-config","date":"2016-04-26T10:48:11.000Z","updated":"2019-08-21T15:13:24.147Z","comments":true,"path":"ubuntu-dev-config.html","link":"","permalink":"http://zhangfuxin.cn/ubuntu-dev-config.html","excerpt":"** ubuntu开发环境配置：** &lt;Excerpt in index | 首页摘要&gt; ubuntu16下node,java开发环境配置","text":"** ubuntu开发环境配置：** &lt;Excerpt in index | 首页摘要&gt; ubuntu16下node,java开发环境配置 &lt;The rest of contents | 余下全文&gt; ubuntu14升级到ubuntu16 终端下执行命令sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade 重启系统以完成更新的安装sudo init 6 用命令安装更新管理器核心update-manager-core，如果服务器已安装则可以跳过sudo apt-get install update-manager-core 编辑/etc/update-manager/release-upgrades配置文件，设置Prompt=ltssudo vi /etc/update-manager/release-upgrades 启动升级进程sudo do-release-upgrade -d 安装系统软件 更新系统和软件 12sudo apt-get updatesudo apt-get upgade 谷歌浏览器，火狐浏览器，atom编辑器，sublime编辑器，webstome,idea,eclipse 安装搜狗输入法（官网），安装fcitx配置搜狗输入法 安装jdk 下载jdk并新建一个文件夹 1sudo mkdir /usr/lib/jvm 解压文件 1sudo tar zxvf jdk-7u71-linux-x64.tar.gz -C /usr/lib/jvm/jdk1.7 设置环境变量,设置~/.zshrc文件,或者编辑/etc/profile（全局）文件 1234export JAVA_HOME=/usr/lib/jvm/jdk1.7export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 检查是否安装成功 打开shell, 1java --version 安装nodejs nodejs版本迭代较快，有时候需要检查在不同版本下的兼容性问题，用nvm来控制版本 安装nvm,source的时候根据自己的shell版本，~/.bashrc, ~/.profile, 或者 ~/.zshrc 1234curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bashexport NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvmsource ~/.profile 安装不同版本的nodejs 12345nvm ls-remotenvm install v0.12.9nvm install 5.0nvm use 0.12.9nvm alias default 0.12.9 安装mongodb 配置公钥 12sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10echo \"deb http://repo.mongodb.org/apt/ubuntu \"$(lsb_release -sc)\"/mongodb-org/3.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.0.list 更新软件列表 12sudo apt-get updatesudo apt-get install -y mongodb-org 完成上面的安装步骤配置mongodb的数据库的位置 1sudo mongod --dbpath /data/db 启动mongod 123sudo service mongod startsudo service mongod stopsudo service mongod restart 安装redis 下载软件 1wget http://download.redis.io/releases/redis-2.8.11.tar.gz 解压安装 12tar xvfz redis-2.8.11.tar.gzcd redis-2.8.11 &amp;&amp; sudo make &amp;&amp; sudo make install 配置使用 下载配置文件和init启动脚本 12345wget https://github.com/ijonas/dotfiles/raw/master/etc/init.d/redis-serverwget https://github.com/ijonas/dotfiles/raw/master/etc/redis.confsudo mv redis-server /etc/init.d/redis-serversudo chmod +x /etc/init.d/redis-serversudo mv redis.conf /etc/redis.conf 初始化用户和日志路径 12345sudo useradd redissudo mkdir -p /var/lib/redissudo mkdir -p /var/log/redissudo chown redis.redis /var/lib/redissudo chown redis.redis /var/log/redis 设置开机自动启动，关机自动关闭 1sudo update-rc.d redis-server defaults 环境变量配置 认识环境变量相关的文件 /etc/profile —— 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置； /etc/environment —— 在登录时操作系统使用的第二个文件,系统在读取你自己的profile前,设置环境文件的环境变量； /etc/bashrc —— 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取； ~/.profile —— 每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次！默认情况下,它设置一些环境变量,执行用户的.bashrc文件； ~/.bashrc —— 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取； 配置环境变量 在Ubuntu14.04的~/.bashrc中添加的环境变量,在文件添加 1export PATH=$PATH:/home/qtcreator-2.6.1/bin 修改profile文件,vim编辑/etc/profile 12sudo vim /etc/profilesource /etc/profile 安装开发工具 zsh命令行工具 mysql客户端workbench，mongo客户端工具robomongo 安装git,svn版本控制工具12sudo apt-get install gitsudo apt-get install subversion","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://zhangfuxin.cn/tags/linux/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}]},{"title":"我的梦想","slug":"dream","date":"2016-04-24T14:07:27.000Z","updated":"2019-08-21T15:13:24.122Z","comments":true,"path":"dream.html","link":"","permalink":"http://zhangfuxin.cn/dream.html","excerpt":"** 我的梦想：** &lt;Excerpt in index | 首页摘要&gt; 一个人如果活着没有梦想,那和咸鱼有什么区别?","text":"** 我的梦想：** &lt;Excerpt in index | 首页摘要&gt; 一个人如果活着没有梦想,那和咸鱼有什么区别? 请问你的梦想是什么? &lt;The rest of contents | 余下全文&gt; 我的梦想是什么? 刚开始接触编程的时候,感觉代码是个神器的世界,在这里你可以为所欲为,然后看到很多大神的框架,软件,在使用别人好的框架,好的软件,那一刻我感觉 “我的梦想就是用代码改变世界!” 感觉自己迷失了好久,找不到方向,曾经的激情不知道去了哪里? 开始追梦 有了梦想,我开始了疯狂的奋斗,每天休息4,5个小时,全身心去学习编程,努力还是很快得到了回报,我用了3个月就入门学好了java,然后找了java程序员的工作,就这样开始了我程序员的追梦之旅! 初级程序员 虽然入门了,但是刚开始的工作并不是一帆风顺的.我还记得第一份任务,老大让我写一个稍微复杂的接口,客户专用的接口,使用springmvc,还要提交到git上,对我而言,这一切都是新东西,经过我几天的努力,还是搞砸了,就这样第一个任务以失败告终! 虽然第一个任务失败了,但是工作还在继续,我还是继续努力的工作,我必须承认我不是编程的天才,可能别人一个小时完成的任务,我需要一个半小时,但是我必须做好,因为我有梦想! 中级程序员 在工作的时候就感觉时间飞逝,一天天很快过去.晚上睡觉的时候,我就会问自己,我今天到底做了什么功能?我收获了哪些技能?曾经有段时间每天都是该页面,我几乎烦的崩溃,感觉每天都在做无用的东西,后来发现,无论是前段后端,其实都是必不可少的技能,我的心态应该调整,让自己去喜欢前段,同时保持后端的热情. 一个成熟的程序员和菜鸟最大的区别应该是心态! 高级程序员 不再是代码搬运工，根据业务和需求自己随便造个轮子什么的。强大的代码能力，考虑事情应该全面，深刻 架构师 未完待续","categories":[{"name":"个人随笔","slug":"个人随笔","permalink":"http://zhangfuxin.cn/categories/个人随笔/"}],"tags":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/tags/others/"}],"keywords":[{"name":"个人随笔","slug":"个人随笔","permalink":"http://zhangfuxin.cn/categories/个人随笔/"}]},{"title":"程序员入门指南","slug":"coder-study","date":"2016-04-17T04:37:19.000Z","updated":"2019-08-21T15:13:24.120Z","comments":true,"path":"coder-study.html","link":"","permalink":"http://zhangfuxin.cn/coder-study.html","excerpt":"** 程序员入门指南 ：** &lt;Excerpt in index | 首页摘要&gt; 程序员入门必须了解的一些知识，个人经验，不喜勿喷！","text":"** 程序员入门指南 ：** &lt;Excerpt in index | 首页摘要&gt; 程序员入门必须了解的一些知识，个人经验，不喜勿喷！ &lt;The rest of contents | 余下全文&gt; 程序员的入门规划1.我该学习什么语言？ 这个问题困扰了几乎所有的程序员，比如java应用广好就业，比如php入门简单，ios待遇高， python是万能语言，HTML和js前端缺人才等等 个人见解：先学习难度小，大众化的编程语言，比如java，php，python，javascript,c/c++,这几个学哪一种其实差不多，入门以后看自己兴趣在进行其它语言的学习。 2.我该怎么学习编程？这个问题是所有的程序员都有的，我也经常会疑问，到底该怎么学习呢？ 个人见解： 先了解语言的特性，适用的范围场景，比如是适合web开发，还是适合客户端程序，有的适合并发多线程，有的适合异步，还有的比较稳定，适合构建大型项目，有的开发效率高，等等。 了解语言的语法和常用api的使用，比如变量的声明，循环的使用，io的读取，http服务的创建，把这些基本的语法搞清楚，在进行下一步的学习。 学习web开发之前的准备，数据库的学习，http协议的学习，html，css和javacript的常用知识了解 学习常用框架，比如java学习常用的ssh三大框架，node的学习express，一定要做2个项目练习，把自己的之前学习的知识都巩固一下， 总结一下自己学习的过程，明白编程的思想在哪里，思路在哪里，学习编程，首先应该培养的是编程的思维和思想，有个正确的思维后面都简单多了。 养成写博客或者学习笔记的习惯，推荐写博客， 熟悉项目管理工具，svn，git之类的必须要会，工作中这些都是必须的 准备面试，通过面试题进一步巩固自己的知识，夯实基础。 3.我应该去哪里学习编程？其实这个看个人，如果自学能力强，自控能力强，自学挺好的，下面我列举几个程序员常用的网站 网易云课堂，很多免费的视频课程，适合入门学习 慕课网，很多it入门教学视频，资源也不错 极客学院，和前两个网站差不多， 北风网，类似的教学网站，其它的就不说了 4.编程遇到问题怎么办？ 百度或者谷歌看看网上有没有类似的问题，一回生，二回熟，很快就明白了 去官网查看api文档查找原因 自己要学会debug代码，查找原因 去各大论坛逛逛，说不定早有人提问此类问题了 5.我想看编程的书籍去哪找呢？经典书籍还是买纸质的，买正版的，支持正版！ 新浪微盘，非常多的it书籍 脚本之家，非常多的pdf书籍，可惜大多数不是文字版pdf 英文原版书籍，都是高清文字版pdf，强烈推荐，都是英文原版的 计算机书控，都是免费的pdf文档，大多数不是文字版pdf 6.代码资源 最好的代码仓库 github csdn代码仓库 gist 代码片段之家 7.学习心态 不要老是折腾工具，ide工具和文本编辑器一样一个就够了 不要自满，编程的东西学一辈子也学不会，要谦虚好学 不要急躁，既然知识学不完，我们应该掌握学习方法，指定计划去学习 要持之以恒，学习是一辈子的事，如果你没有这个打算，还是不要做程序员的好 切忌眼高手低，必须要敲代码才能达到效果 8.编程进阶之路当有了一定的编程基础之后,最大的问题是确定自己的方向,这个时候最容易迷茫和困惑,学习什么技术?怎么去学,这些真的很难 个人建议如下:1.技术型方向:提高自己的编程能力和语言造诣,最有效的是”造轮子”,量变引起质变 写插件,写框架,写爬虫,写数据库,自制编程语言,等等.2.业务型方向:提高自己的业务能力,和客户的沟通能力,分析需求,解决客户的难题 多出去见客户,去现场,了解需求,分析需求,","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhangfuxin.cn/categories/编程语言/"}],"tags":[{"name":"others","slug":"others","permalink":"http://zhangfuxin.cn/tags/others/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhangfuxin.cn/categories/编程语言/"}]},{"title":"hexo和github打造个人博客","slug":"hexo-githup-blog","date":"2015-12-20T14:35:04.000Z","updated":"2019-08-21T15:13:24.127Z","comments":true,"path":"hexo-githup-blog.html","link":"","permalink":"http://zhangfuxin.cn/hexo-githup-blog.html","excerpt":"** hexo和github打造个人博客 ：** &lt;Excerpt in index | 首页摘要&gt; 使用hexo和github打造属于自己的静态博客，展示自己的作品，思想……","text":"** hexo和github打造个人博客 ：** &lt;Excerpt in index | 首页摘要&gt; 使用hexo和github打造属于自己的静态博客，展示自己的作品，思想…… &lt;The rest of contents | 余下全文&gt; ##说明 自己在使用hexo搭建静态博客的时候踩了许多坑,最终去官网看教程搞定了, 建议用hexo搭建个人博客的时候,最好看清教程的日期和使用的版本,这样就 不会因为版本的不同导致的问题了.建议先去hexo官网了解一下 hexo官网 1.准备工作 安装nodejs 去官网下载nodejs安装(推荐安装4.x),安装之后在命令行 node -v,如果成功说明node环境ok,不成功就去环境变量配置一下. 安装hexo 使用命令 npm install hexo -g,执行hexo -v 查看版本,本教程适合3.1.1以上版本 安装git 去官网下载git安装,不会自行百度 配置git 配置ssh私钥,上传到github上 2.github-pages的说明 github有两种主页,一种是github-page(个人主页),一种是项目主页,本教程针对个人主页 github-page需要将hexo博客发布到repository的master(主干)即可 github的个人主页要求repository的名称和username一致，加入username是tom，则repository的名称为tom.github.io 3.使用hexo写博客- 新建一个文件夹myblog, - 右键git bash here使用git的shell - 在shell中输入hexo init,回车执行 - 在shell中输入hexo g ,回车 - 在shell中hexo s,回车 - 去浏览器访问http://localhost:4000,访问到主页,然后在shell中ctrl c停止 - 在shell中hexo new &quot;first-blog&quot;,回车 - 在shell中hexo g ,回车 - 在shell中hexo s ,回车,在访问 - ok,在本地测试就没问题了4.发布到github打开项目根部录下的.config.yml,找到deploy,修改如下: 123deploy: - type: git repo: git@github.com:yourname/yourname.github.io.git,master 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 访问地址就是 http://tom.github.io/ 5.常用命令命令的简写为： 12345hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deployhexo clean 删除public文件夹6.常见问题 部署时出现git not found npm install hexo-deployer-git –save 安装依赖包 7.详细设置每个人对自己的博客都有不一样的要求，比如主题，分类，标签，评论插件的选择， 这些对程序员的你来说，都是小菜一碟，下面是官网教程： hexo官方文档 博客效果可以看我的个人博客 我的个人博客","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://zhangfuxin.cn/tags/hexo/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://zhangfuxin.cn/categories/开发工具/"}]},{"title":"node学习","slug":"node-study","date":"2015-12-19T10:58:56.000Z","updated":"2019-08-21T15:13:24.134Z","comments":true,"path":"node-study.html","link":"","permalink":"http://zhangfuxin.cn/node-study.html","excerpt":"** node学习： ** &lt;Excerpt in index | 首页摘要&gt; nodejs学习的方法，进阶路线","text":"** node学习： ** &lt;Excerpt in index | 首页摘要&gt; nodejs学习的方法，进阶路线 &lt;The rest of contents | 余下全文&gt; 一 学习内容 node的常用模块,buffer,fs,http,net等. node常用框架express,mongoose,koa,mocha,should 部署上线,pm2,grunt, 二 学习要点 了解node的特性和语法 编写扩展node模块 用异步的思想编程 常用框架的使用 回调的解决方案(promise) 三 入门实战 参照nodejs实战上的微博系统,使用express4.x+ mongoose实现 使用socket.io实现一个简单的即时聊天的系统 使用mongoose+express+node开发一个论坛系统 使用koa+mongoose做一个简单的cms或者权限系统 四 学习方法 建议有基础的直接开始入门实战,在练习中熟悉node的api,做完一个项目再去看书 不要一直看书,没什么效果的,实战永远是最有效的","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhangfuxin.cn/categories/编程语言/"}],"tags":[{"name":"node","slug":"node","permalink":"http://zhangfuxin.cn/tags/node/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhangfuxin.cn/categories/编程语言/"}]}]}